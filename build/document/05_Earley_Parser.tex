%
\begin{isabellebody}%
\setisabellecontext{{\isadigit{0}}{\isadigit{5}}{\isacharunderscore}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}Parser}%
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupchapter{Earley Parser Implementation \label{chap:05}%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
Although a recognizer is a useful tool, for most practical applications we would like to not only
know if the language specified by the grammar accepts the input, but we also want to obtain additional information
of how the input can be derived in the form of parse trees. In particular, for our running example, the
grammar $S ::= S + S \,\, | \,\, x$ and the input $\omega = x + x + x$, we want to obtain the two possible parse
trees illustrated in Figures \ref{fig:tree1} and \ref{fig:tree2}. But constructing all possible parse trees at once is no
trivial task.

\begin{figure}[htpb]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \psframebox[linestyle=none,framesep=10pt]{%
        \pstree{\LFTr{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
          \pstree{\LFTr{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]x}
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]x}}}
          \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
          \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]S}}}}
        \caption{Parse Tree: $\omega = (x + x) + x$} \label{fig:tree1}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \psframebox[linestyle=none,framesep=10pt]{%
        \pstree{\LFTr{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
          \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]x}
          \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
          \pstree{\LFTr{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]x}
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]x}}}}}}
        \caption{Parse Tree: $\omega = x + (x + x)$} \label{fig:tree2}
    \end{minipage}
\end{figure}

Earley \cite{Earley:1970} extends his recognizer to a parser by adding the following
pointers. If the algorithm performs a completion and constructs an item $B \rightarrow \, \alpha A \bullet \beta, i, k$,
it adds a pointer from the \textit{instance of the non-terminal} $A$ to the complete item
$A \rightarrow \, \gamma \bullet, j, k$. If there exists more than one possible way to complete the non-terminal
$A$ and obtain the item $B \rightarrow \, \alpha A \bullet \beta, i, k$, then multiple pointers originate
from the instance of the non-terminal $A$. Annotating every non-terminal of the right-hand side of the item
$A \rightarrow \, \gamma \bullet, j, k$ recursively with pointers thus represents the derivation trees for
the non-terminal $A$. Finally, after termination of the algorithm, the non-terminal that represents the start symbol
contains pointers representing all possible derivation trees.

Note that Earley's pointers connect instances of non-terminals, but Tomita \cite{Tomita:1985} showed
that this approach is incorrect and may lead to spurious derivations in certain cases. Scott \cite{Scott:2008}
presents an example for the grammar $S ::= SS \, | \, x$ and the input $\omega = xxx$. Earley's parser
correctly constructs the parse trees for the input but additionally returns erroneous parse trees representing
derivations of $xx$ and $xxxx$. The problem lies in the fact that left- and rightmost derivations are
intertwined when they should not be, since pointers originate from instances of non-terminals and do not
connect Earley items.

In this chapter we develop an efficient functional algorithm constructing a single parse
tree in Section \ref{sec:parse-tree} and prove its correctness. In Section \ref{sec:parse-forest}
we generalize this approach, introducing a data structure representing all possible parse trees
as a parse forest, adjusting the parse tree algorithm to compute such a forest, prove termination
and soundness of the algorithm, and discuss the missing completeness proof. Finally, in Section \ref{sec:word}
we summarize lessons learned from our approach and highlight a different data representation and
implementation approaches for parse forests, in particular highlighting the algorithms of Scott \cite{Scott:2008}.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsection{A Single Parse Tree \label{sec:parse-tree}%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
The data structure \isa{tree} represents parse trees as shown in Figures \ref{fig:tree1} and \ref{fig:tree2}.
A \isa{Leaf} always contains a single symbol (either terminal or non-terminal for partial derivation trees), a \isa{Branch} consists of one non-terminal
symbol and a list of subtrees. The function \isa{root{\isacharunderscore}{\kern0pt}tree} returns the symbol of the root of the
parse tree. The yield of a leaf is its single symbol; to compute the yield for a branch with
subtrees \isa{ts} we apply the function \isa{yield{\isacharunderscore}{\kern0pt}tree} recursively and concatenate the results.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{datatype}\isamarkupfalse%
\ {\isacharprime}{\kern0pt}a\ tree\ {\isacharequal}{\kern0pt}\isanewline
\ \ Leaf\ {\isacharprime}{\kern0pt}a\isanewline
{\isacharbar}{\kern0pt}\ Branch\ {\isacharprime}{\kern0pt}a\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ tree\ list{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ root{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ tree\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}root{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}Leaf\ a{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ a{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}root{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}Branch\ N\ {\isacharunderscore}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ N{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ yield{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ tree\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ sentential{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}yield{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}Leaf\ a{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}a{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}yield{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}Branch\ {\isacharunderscore}{\kern0pt}\ ts{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ concat\ {\isacharparenleft}{\kern0pt}map\ yield{\isacharunderscore}{\kern0pt}tree\ ts{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\begin{isamarkuptext}%
We introduce three notions of well-formedness for parse trees:
\begin{itemize}
  \item \isa{wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree}: A parse tree must represent a valid derivation tree according to the grammar \isa{{\isasymG}}.
    A leaf of a parse tree is always well-formed by construction. For each branch there has to exist a production rule of the grammar \isa{{\isasymG}}
    such that the root of this branch matches the left-hand side of the production rule, each subtree is in turn well-formed, and
    the roots of the subtrees coincide with the right-hand side of the production rule.
  \item \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree}: Each branch corresponds to an Earley item
    $N \rightarrow \, \alpha \bullet \beta, i, j$ such that the roots of the subtrees match
    the prefix \isa{{\isasymalpha}} up to the bullet of the right-hand side of the item's production rule. Note that a branch is only well-formed according to the grammar \isa{{\isasymG}} if
    the roots of the subtrees form a \textit{complete} right-hand side of a production rule.
    In contrast, a branch is well-formed according to an item if the roots of the subtrees are equal
    to \isa{{\isasymalpha}}, or, since we assume that Earley items are themselves well-formed, a \textit{prefix}
    of a right-hand side of a production rule.
  \item \isa{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree}: For an item $N \rightarrow \, \alpha \bullet \beta, i, j$ the yield
    of a parse tree has to match the substring \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}i{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}j{\isasymrangle}} of the input.
\end{itemize}%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{fun}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ cfg\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isacharunderscore}{\kern0pt}\ {\isacharparenleft}{\kern0pt}Leaf\ a{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ True{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isacharparenleft}{\kern0pt}Branch\ N\ ts{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymexists}r\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}{\isasymRR}\ {\isasymG}{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\ N\ {\isacharequal}{\kern0pt}\ rule{\isacharunderscore}{\kern0pt}head\ r\ {\isasymand}\ map\ root{\isacharunderscore}{\kern0pt}tree\ ts\ {\isacharequal}{\kern0pt}\ rule{\isacharunderscore}{\kern0pt}body\ r{\isacharparenright}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}t\ {\isasymin}\ set\ ts{\isachardot}{\kern0pt}\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ cfg\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isacharunderscore}{\kern0pt}\ {\isacharparenleft}{\kern0pt}Leaf\ a{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ True{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ {\isacharparenleft}{\kern0pt}Branch\ N\ ts{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ N\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ x\ {\isasymand}\ map\ root{\isacharunderscore}{\kern0pt}tree\ ts\ {\isacharequal}{\kern0pt}\ take\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}bullet\ x{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x{\isacharparenright}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}t\ {\isasymin}\ set\ ts{\isachardot}{\kern0pt}\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t\ {\isasymequiv}\ yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isasymrangle}{\isachardoublequoteclose}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Pointer Lemmas%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
In Chapter \ref{chap:04} we extended the algorithm of Chapter \ref{chapter:3} in two orthogonal
ways: implementing sets as lists and adding the additional information to construct parse trees
in the form of null, predecessor, and predecessor/reduction pointers. But we did not formally define
the semantics of these pointers nor prove anything about their construction. In the following we
define and proof soundness of the pointers.

\begin{itemize}
  \item A null pointer \isa{Null} of an entry is sound if it \isa{predicts} the item $x$ of
    the entry, or the bullet of $x$ is at the beginning of the right-hand side of its production rule
    and we have not yet scanned any subsequence of the input, or item end and origin are identical.
  \item A predecessor pointer \isa{Pre\ pre} of an entry $e$ is sound for the input \isa{{\isasymomega}}, bins \isa{bs},
    and the index of the current bin $k$ if $k > 0$, the predecessor index does not exceed the length
    of the predecessor bin at index $k-1$, and the predecessor item in bin $k-1$ at index $pre$ \isa{scans}
    the item of the entry $e$. An item $x'$ \isa{scans} item $x$ for index $k$ if the next symbol of
    $x'$ coincides with the terminal symbol at index $k-1$ in the input \isa{{\isasymomega}} and the item $x$ can be obtained by the function call
    \isa{inc{\isacharunderscore}{\kern0pt}item\ x{\isacharprime}{\kern0pt}\ k}. 
  \item Finally, we define the soundness of a pointer \isa{PreRed\ p\ ps} of an entry $e$ for each predecessor/reduction
    triple \isa{{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}p\ {\isacharhash}{\kern0pt}\ ps{\isacharparenright}{\kern0pt}}. The index $k'$ of the predecessor bin must be strictly
    smaller than $k$, and both the predecessor and the reduction index must be within the bounds of their
    respective bins, or bin $k'$ and $k$. Additionally, predicate \isa{completes} holds for $k$,
    the predecessor item $x'$, the item $x$ of entry $e$ and the reduction item $y$, capturing the semantics of
    the \isa{Complete} operation: the next symbol of $x'$ is the non-terminal $N$ which coincides
    with the item rule head of $y$. Furthermore, the item $y$ is complete and the origin index of $y$
    aligns with the end index of $x'$. Finally, item $x$ can be obtained once more by the function call \isa{inc{\isacharunderscore}{\kern0pt}item\ x{\isacharprime}{\kern0pt}\ k}.
\end{itemize}%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ predicts\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}predicts\ x\ {\isasymequiv}\ item{\isacharunderscore}{\kern0pt}bullet\ x\ {\isacharequal}{\kern0pt}\ {\isadigit{0}}\ {\isasymand}\ item{\isacharunderscore}{\kern0pt}origin\ x\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}end\ x{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}null{\isacharunderscore}{\kern0pt}ptr\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ entry\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}null{\isacharunderscore}{\kern0pt}ptr\ e\ {\isasymequiv}\ pointer\ e\ {\isacharequal}{\kern0pt}\ Null\ {\isasymlongrightarrow}\ predicts\ {\isacharparenleft}{\kern0pt}item\ e{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ scans\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}scans\ {\isasymomega}\ k\ x{\isacharprime}{\kern0pt}\ x\ {\isasymequiv}\ x\ {\isacharequal}{\kern0pt}\ inc{\isacharunderscore}{\kern0pt}item\ x{\isacharprime}{\kern0pt}\ k\ {\isasymand}\ {\isacharparenleft}{\kern0pt}{\isasymexists}a{\isachardot}{\kern0pt}\ next{\isacharunderscore}{\kern0pt}symbol\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ a\ {\isasymand}\ {\isasymomega}{\isacharbang}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ a{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}pre{\isacharunderscore}{\kern0pt}ptr\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ entry\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}pre{\isacharunderscore}{\kern0pt}ptr\ {\isasymomega}\ bs\ k\ e\ {\isasymequiv}\ {\isasymforall}pre{\isachardot}{\kern0pt}\ pointer\ e\ {\isacharequal}{\kern0pt}\ Pre\ pre\ {\isasymlongrightarrow}\isanewline
\ \ \ \ k\ {\isachargreater}{\kern0pt}\ {\isadigit{0}}\ {\isasymand}\ pre\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbar}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ \ \ scans\ {\isasymomega}\ k\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbang}{\kern0pt}pre{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item\ e{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ completes\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}completes\ k\ x{\isacharprime}{\kern0pt}\ x\ y\ {\isasymequiv}\ x\ {\isacharequal}{\kern0pt}\ inc{\isacharunderscore}{\kern0pt}item\ x{\isacharprime}{\kern0pt}\ k\ {\isasymand}\ is{\isacharunderscore}{\kern0pt}complete\ y\ {\isasymand}\ item{\isacharunderscore}{\kern0pt}origin\ y\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}end\ x{\isacharprime}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymexists}N{\isachardot}{\kern0pt}\ next{\isacharunderscore}{\kern0pt}symbol\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ N\ {\isasymand}\ N\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ y{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}prered{\isacharunderscore}{\kern0pt}ptr\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ entry\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}prered{\isacharunderscore}{\kern0pt}ptr\ bs\ k\ e\ {\isasymequiv}\ {\isasymforall}p\ ps\ k{\isacharprime}{\kern0pt}\ pre\ red{\isachardot}{\kern0pt}\ pointer\ e\ {\isacharequal}{\kern0pt}\ PreRed\ p\ ps\ {\isasymand}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}p{\isacharhash}{\kern0pt}ps{\isacharparenright}{\kern0pt}\ {\isasymlongrightarrow}\ k{\isacharprime}{\kern0pt}\ {\isacharless}{\kern0pt}\ k\ {\isasymand}\ pre\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharbar}{\kern0pt}\ {\isasymand}\ red\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbar}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ \ \ completes\ k\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharbang}{\kern0pt}pre{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item\ e{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}red{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs\ {\isasymequiv}\ {\isasymforall}k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}{\isachardot}{\kern0pt}\ {\isasymforall}e\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\isanewline
\ \ \ \ sound{\isacharunderscore}{\kern0pt}null{\isacharunderscore}{\kern0pt}ptr\ e\ {\isasymand}\ sound{\isacharunderscore}{\kern0pt}pre{\isacharunderscore}{\kern0pt}ptr\ {\isasymomega}\ bs\ k\ e\ {\isasymand}\ sound{\isacharunderscore}{\kern0pt}prered{\isacharunderscore}{\kern0pt}ptr\ bs\ k\ e{\isachardoublequoteclose}%
\begin{isamarkuptext}%
We then prove the semantics of the pointers. The structure of the proofs is as usual: we first
prove pointer soundness for the most basic operations \isa{bin{\isacharunderscore}{\kern0pt}upd}, \isa{bin{\isacharunderscore}{\kern0pt}upds}, and \isa{bins{\isacharunderscore}{\kern0pt}upd}.
Followed by the corresponding proofs for the computation of a single bin or functions \isa{Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharprime}{\kern0pt}}
and \isa{Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list}. Finally, we prove that the initial bins only contain sound pointers, and functions \isa{Earley{\isacharunderscore}{\kern0pt}list}
and \isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list} maintain this property. Although it should be intuitively clear that the
semantics of pointers hold, since the predicates \isa{predicts}, \isa{scans}, and \isa{completes} basically
restate the conditions of the operations \isa{Predict}, \isa{Scan}, and \isa{Complete} or their list variations,
and the bounds of the indices are sound by construction. But the proofs are surprisingly not trivial at all, especially the soundness
proofs for functions \isa{bin{\isacharunderscore}{\kern0pt}upd} and \isa{Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharprime}{\kern0pt}}. The complexity mostly stems from
the predecessor/reduction case that requires a quite significant amount of case splitting due to the indexing and dependence
on the type of the pointers of the newly inserted items. Nonetheless, we only state the proofs and do not go into detail.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}upd{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}distinct\ {\isacharparenleft}{\kern0pt}items\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}null{\isacharunderscore}{\kern0pt}ptr\ e{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}pre{\isacharunderscore}{\kern0pt}ptr\ {\isasymomega}\ bs\ k\ e{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}prered{\isacharunderscore}{\kern0pt}ptr\ bs\ k\ e{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}bs{\isacharbrackleft}{\kern0pt}k\ {\isacharcolon}{\kern0pt}{\isacharequal}{\kern0pt}\ bin{\isacharunderscore}{\kern0pt}upd\ e\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}upds{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}distinct\ {\isacharparenleft}{\kern0pt}items\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}distinct\ {\isacharparenleft}{\kern0pt}items\ es{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isasymforall}e\ {\isasymin}\ set\ es{\isachardot}{\kern0pt}\ sound{\isacharunderscore}{\kern0pt}null{\isacharunderscore}{\kern0pt}ptr\ e\ {\isasymand}\ sound{\isacharunderscore}{\kern0pt}pre{\isacharunderscore}{\kern0pt}ptr\ {\isasymomega}\ bs\ k\ e\ {\isasymand}\ sound{\isacharunderscore}{\kern0pt}prered{\isacharunderscore}{\kern0pt}ptr\ bs\ k\ e{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}bs{\isacharbrackleft}{\kern0pt}k\ {\isacharcolon}{\kern0pt}{\isacharequal}{\kern0pt}\ bin{\isacharunderscore}{\kern0pt}upds\ es\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharprime}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}k{\isacharcomma}{\kern0pt}\ {\isasymG}{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ bs{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}earley{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}items\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}bins\ bs{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\ \isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharprime}{\kern0pt}\ k\ {\isasymG}\ {\isasymomega}\ bs\ i{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}k{\isacharcomma}{\kern0pt}\ {\isasymG}{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ bs{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}earley{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}items\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}bins\ bs{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list\ k\ {\isasymG}\ {\isasymomega}\ bs{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}Init{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}Init{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}k\ {\isasymle}\ {\isacharbar}{\kern0pt}{\isasymomega}{\isacharbar}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}list\ k\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{A Parse Tree Algorithm%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
After execution of the \isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list} algorithm we obtain bins representing the complete set
of Earley items. The null, predecessor, and predecessor/reduction pointers provide a way to navigate
between items or through these bins, and, since they are sound, a way to construct derivation trees.
The function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}} constructs a \textit{single} parse tree corresponding to the item $x$ of entry $e$ at index $i$ of the $k$-th bin according to the
well-formedness definitions for parse trees from the beginning of this section.

If the pointer of entry $e$ is a null pointer, the algorithm starts building the tree rooted at
the left-hand side non-terminal $N$ of the production rule of the item $x$ by constructing an initially
empty branch containing the non-terminal $N$ and an empty list of subtrees. If the algorithm encounters
a predecessor pointer \isa{Pre\ pre}, it first recursively calls itself, for the previous bin $k-1$ and the
predecessor index \isa{pre}, obtaining a partial parse branch. Since the predecessor pointer is sound,
in particular the \isa{scans} predicate holds, we append a Leaf containing the terminal symbol at index
$k-1$ of the input \isa{{\isasymomega}} to the list of substrees of the branch. In the case that
the pointer contains predecessor/reduction triples the algorithm only considers the first triple
\isa{{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}} due to the fact that we are only constructing a single derivation tree. As for the predecessor
case, it recursively calls itself obtaining a partial derivation tree \isa{Branch\ N\ ts} for the predecessor index \isa{pre}
and bin $k'$, followed by yet another recursive call for the reduction item at the reduction index \isa{red}
in the current bin $k$, constructing a complete derivation tree $t$. This time the \isa{completes}
predicate holds, thus the next symbol of the predecessor item coincides with the item rule head of
the reduction item, or we are allowed to append the complete tree $t$ to the list of substrees \isa{ts}.

Some minor implementation details to note are: the function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}} is a partial function,
and not tail recursive, hence it has to return an optional value, as explained in Section \ref{sec:04-wellformedness}.
Furthermore, we are using the monadic do-notation commonly found in functional programming languages for the option
monad. An alternative but equivalent implementation would use explicit case distinctions. Finally, if
the function computes some value it is always a branch, never a single leaf.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{partial{\isacharunderscore}{\kern0pt}function}\isamarkupfalse%
\ {\isacharparenleft}{\kern0pt}option{\isacharparenright}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ option{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ let\ e\ {\isacharequal}{\kern0pt}\ bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i\ in\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ case\ pointer\ e\ of\isanewline
\ \ \ \ \ \ Null\ {\isasymRightarrow}\ Some\ {\isacharparenleft}{\kern0pt}Branch\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ {\isacharparenleft}{\kern0pt}item\ e{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ {\isacharbar}{\kern0pt}\ Pre\ pre\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ do\ {\isacharbraceleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ t\ {\isasymleftarrow}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}\ pre{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ case\ t\ of\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ Branch\ N\ ts\ {\isasymRightarrow}\ Some\ {\isacharparenleft}{\kern0pt}Branch\ N\ {\isacharparenleft}{\kern0pt}ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}Leaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}{\isacharbang}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ {\isacharbar}{\kern0pt}\ {\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ None\ {\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ {\isacharbar}{\kern0pt}\ PreRed\ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ {\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ do\ {\isacharbraceleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ t\ {\isasymleftarrow}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k{\isacharprime}{\kern0pt}\ pre{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ case\ t\ of\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ Branch\ N\ ts\ {\isasymRightarrow}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ do\ {\isacharbraceleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ t\ {\isasymleftarrow}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ red{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Some\ {\isacharparenleft}{\kern0pt}Branch\ N\ {\isacharparenleft}{\kern0pt}ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}t{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isacharbraceright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ {\isacharbar}{\kern0pt}\ {\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ None\ {\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\begin{isamarkuptext}%
The function \isa{build{\isacharunderscore}{\kern0pt}tree} computes a complete derivation tree if there exists one. It searches the last bin for any finished items or items of the form
$S \rightarrow \gamma \bullet, 0, n$ where $S$ is the start symbol of the grammar \isa{{\isasymG}} and $n$ denotes
the length of the input \isa{{\isasymomega}}. If there exists such an item, it calls function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}}
obtaining some parse tree representing the derivation \isa{{\isasymG}\ {\isasymturnstile}\ S\ \ensuremath{\Rightarrow^{\ast}}\ {\isasymomega}} (we will have to prove that this call never returns \isa{None}),
otherwise it returns \isa{None} since there cannot exist a valid parse tree due to the correctness
proof for the Earley bins of Chapter \ref{chapter:3} if the argument \isa{bs} was constructed by the
\isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list} function.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ cfg\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ option{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isasymomega}\ bs\ {\isasymequiv}\isanewline
\ \ \ \ let\ k\ {\isacharequal}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}\ in\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ case\ filter{\isacharunderscore}{\kern0pt}with{\isacharunderscore}{\kern0pt}index\ {\isacharparenleft}{\kern0pt}{\isasymlambda}x{\isachardot}{\kern0pt}\ is{\isacharunderscore}{\kern0pt}finished\ {\isasymG}\ {\isasymomega}\ x{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}items\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ of\isanewline
\ \ \ \ \ \ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}\ {\isasymRightarrow}\ None\isanewline
\ \ \ \ {\isacharbar}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isacharunderscore}{\kern0pt}{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}{\isacharhash}{\kern0pt}{\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Termination \label{q}%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
The function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}} uses the null, predecessor and predecessor/reduction pointers to
navigate through the given bins by calling itself recursively. Sound pointers ensure that we are not
indexing outside of the bins, but this does not imply that the algorithm terminates. In the following
we outline the cases for which it always terminates with some parse tree. Let's assume the
function starts its computation at index $i$ of the $k$-th bin. If it encounters a null pointer, it
terminates immediately. If the pointer is a simple predecessor pointer, it calls itself recursively
for the previous bin. Due to the soundness of the predecessor pointer the index $k-1$ of this bin
is strictly smaller than $k$. A similar argument holds for the first recursive call if the pointer
is a predecessor/reduction pointer for the predecessor case, or for the index of the predecessor bin $k'$ we have \isa{k{\isacharprime}{\kern0pt}\ {\isacharless}{\kern0pt}\ k}. Consequently, we are following
the pointers \textit{strictly} back to the origin bin $B_0$ and thus must terminate at some point. But for
the reduction pointer \isa{red} we run into a problem: the recursive call for the item at index $i$ is in the same
bin $k$. The entry at this position might again contain a reduction pointer \isa{red{\isacharprime}{\kern0pt}} leading to yet another recursive call
for the same bin $k$, and so on.
Hence, it is possible that we end up in a cycle of reductions and never terminate. Take for example the
grammer $A ::= x \, | \, B, \, B ::= A$ and the input $\omega = x$. Table \ref{tab:cyclic-pointers}
illustrates the bins computed by the algorithm of Chapter \ref{chapter:3}. Bin $B_1$ contains the entry
$B \rightarrow \, A \bullet, 0, 1; (0, 2, 0),(0, 2, 2)$ at index $1$ and its second reduction triple
$(0, 2, 2)$ a reduction pointer to index $2$ of the same bin. There we find the entry
$A \rightarrow \, B \bullet, 0, 1; (0, 0, 1)$ with a reduction pointer to index $1$ completing the
cycle. This is indeed valid since the grammar itself is cyclic, allowing for derivations of the form
$A \rightarrow \, B \rightarrow \, A \rightarrow \dots \rightarrow \, A \rightarrow \, x$.

  \begin{table}[htpb]
    \caption[Cyclic reduction pointers]{Cyclic reduction pointers} \label{tab:cyclic-pointers}
    \centering
    \begin{tabular}{| l | l | l |}
          & $B_0$                                     & $B_1$ \\
      \midrule
        0 & $A \rightarrow \, \bullet B, 0, 0; \bot$  & $A \rightarrow \, x \bullet, 0, 1; 1$ \\
        1 & $A \rightarrow \, \bullet x, 0, 0; \bot$  & $B \rightarrow \, A \bullet, 0, 1; (0, 2, 0),(0, 2, 2)$ \\
        2 & $B \rightarrow \, \bullet A, 0, 0; \bot$  & $A \rightarrow \, B \bullet, 0, 1; (0, 0, 1)$ \\
    \end{tabular}
  \end{table}

We need to address this problem when constructing all possible parse trees in Section \ref{sec:parse-forest},
but for now we are lucky. While constructing a single parse tree the algorithm always follows the
first reduction triple that is created when the entry is constructed initially. Since we only
append new entries to bins, the complete reduction item that lead to the creation of the new entry with the
reduction triple necessarily appears strictly before this entry. Furthermore, the implementation of the function \isa{bin{\isacharunderscore}{\kern0pt}upd} also makes sure to not change this
first triple. Thus, we know for any item at index $i$ in the $k$-th bin that its first reduction pointer $red$,
that we follow while constructing a single parse tree, is strictly smaller than $i$.

To summarize:
if the algorithm encounters a null pointer it terminates immediately, for predecessor pointers it
calls itself recursively in a bin with a strictly smaller index, and for reduction pointers it calls
itself in the same bin but for a strictly smaller index.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ mono{\isacharunderscore}{\kern0pt}red{\isacharunderscore}{\kern0pt}ptrs\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}mono{\isacharunderscore}{\kern0pt}red{\isacharunderscore}{\kern0pt}ptrs\ bs\ {\isasymequiv}\ {\isasymforall}k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}{\isachardot}{\kern0pt}\ {\isasymforall}i\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbar}{\kern0pt}{\isachardot}{\kern0pt}\isanewline
\ \ \ \ {\isasymforall}k{\isacharprime}{\kern0pt}\ pre\ red\ ps{\isachardot}{\kern0pt}\ pointer\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ PreRed\ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ ps\ {\isasymlongrightarrow}\ red\ {\isacharless}{\kern0pt}\ i{\isachardoublequoteclose}%
\begin{isamarkuptext}%
The proofs for the monotonicity of the first
reduction pointer for functions \isa{bin{\isacharunderscore}{\kern0pt}upd}, \isa{bin{\isacharunderscore}{\kern0pt}upds}, \isa{bins{\isacharunderscore}{\kern0pt}upd}, \isa{Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharprime}{\kern0pt}},
\isa{Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list}, \isa{Earley{\isacharunderscore}{\kern0pt}list}, and \isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list} are completely analogous to
the soundness proof of the pointers. We omit them.%
\end{isamarkuptext}\isamarkuptrue%
%
\begin{isamarkuptext}%
Similarly to Chapter \ref{chapter:3} we define a suitable measure and a notion of well-formedness
for the input of the function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}} and prove a suitable induction schema, in
the following referred to as \textit{tree induction}, by complete induction on the measure.
For the input quadruple \isa{{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}} the measure corresponds to the number of entries
in the first $k-1$ bins plus $i$. If the algorithm calls itself recursively for predecessor bins
$k-1$ or $k'$, that are respectively strictly less than $k$, the measure decreases by at least $i+1$,
and for any reduction index \isa{red} it decreases by $i - \mathit{red} > 0$. We call the input well-formed if it satisfies the following
conditions: sound and monotonic pointers, the bin index $k$ does not exceed the length of the bins, and the item
index $i$ is within the bounds of the $k$-th bin.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{fun}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}measure\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ bins\ {\isasymtimes}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ nat{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}measure\ {\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ foldl\ {\isacharparenleft}{\kern0pt}{\isacharplus}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isadigit{0}}\ {\isacharparenleft}{\kern0pt}map\ length\ {\isacharparenleft}{\kern0pt}take\ k\ bs{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharplus}{\kern0pt}\ i{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}input\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ bins\ {\isasymtimes}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat{\isacharparenright}{\kern0pt}\ set{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}input\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}\ {\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}\ {\isacharbar}{\kern0pt}\ bs\ {\isasymomega}\ k\ i{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs\ {\isasymand}\ mono{\isacharunderscore}{\kern0pt}red{\isacharunderscore}{\kern0pt}ptrs\ bs\ {\isasymand}\ k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isasymand}\ i\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbar}{\kern0pt}\ {\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}%
\begin{isamarkuptext}%
To conclude this subsection, we prove termination of the function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}}, or for
well-formed input it always terminates with some branch, by \textit{tree induction}.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}termination{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymexists}N\ ts{\isachardot}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ {\isacharequal}{\kern0pt}\ Some\ {\isacharparenleft}{\kern0pt}Branch\ N\ ts{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Correctness%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
We know that for well-formed input a call of the form \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i} always terminates
and yields some parse tree $t$ from the previous lemma. The following lemma proves that for well-formed bins
$t$ represents a parse tree according to the semantics of the Earley item $N \rightarrow \, \alpha \bullet \beta, j, k$
at index $i$ in the $k$-th bin. The parse tree is rooted at the item rule head $N$, each of its subtrees is a complete derivation
tree following the rules of the grammar, and the list of roots of the subtrees themselves coincide with
\isa{{\isasymalpha}}. Moreover, the yield of $t$ matches the subsequence from $j$ to $k$ of the input \isa{{\isasymomega}}.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}bins\ {\isasymG}\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ {\isacharequal}{\kern0pt}\ Some\ t{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ t\ {\isasymand}\ wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ t{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
\begin{proof}

The proof is by \textit{tree induction} and we split it into three cases according to the kind
of pointer the algorithm encounters. Let $e$ denote the entry at index $i$ in bin $k$, and $x$
be the item of $e$, or $x = N \rightarrow \, \alpha \bullet \beta, j, k$.

\begin{itemize}

  \item \isa{pointer\ e\ {\isacharequal}{\kern0pt}\ Null}: 
    We have \isa{t\ {\isacharequal}{\kern0pt}\ Branch\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ x{\isacharparenright}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}}. The root of $t$ coincides
    with the item rule head of $x$ by construction. Since the list of subtrees is empty, each of
    the subtrees is trivially well-formed according to the grammar. Moreover, we know \isa{predicts\ x},
    due to the null pointer, or the bullet of $x$ is at position $0$. Thus, we have \isa{{\isasymalpha}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}} and
    the list of subtrees \isa{{\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}} matches. In summary, we have \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t}.
    From \isa{predicts\ x}, we also know that \isa{j\ {\isacharequal}{\kern0pt}\ k}, or \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}j{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}k{\isasymrangle}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}} by definition
    of the \isa{slice} function. Since the yield of $t$ is empty, we have \isa{\mbox{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t}}
    and conclude the proof for the null pointer.

  \item \isa{pointer\ e\ {\isacharequal}{\kern0pt}\ Pre\ pre}:
    Let $x'$ denote the predecessor \isa{item\ {\isacharparenleft}{\kern0pt}bs\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}\ {\isacharbang}{\kern0pt}\ pre{\isacharparenright}{\kern0pt}} of the recursive function call for
    bin $k-1$ and index \isa{pre}. The function always terminates with some branch for well-formed input.
    Hence, there exists a tree \isa{Branch\ N\ ts} corresponding to the predecessor item $x'$, and we have:
    $$\isa{t\ {\isacharequal}{\kern0pt}\ Branch\ N\ {\isacharparenleft}{\kern0pt}ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}Leaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}}$$

    We also have \isa{{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharcomma}{\kern0pt}\ pre{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}input} by assumption since the predecessor pointer
    is sound and the algorithm does not change the bins. Thus we can use the induction hypothesis and obtain:
    
    \begin{equation*}
      \begin{alignedat}{2}
        & \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x{\isacharprime}{\kern0pt}\ {\isacharparenleft}{\kern0pt}Branch\ N\ ts{\isacharparenright}{\kern0pt}} \qquad & (\isa{IH\isactrlsub {\isadigit{1}}}) \\
        & \isa{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x{\isacharprime}{\kern0pt}\ {\isacharparenleft}{\kern0pt}Branch\ N\ ts{\isacharparenright}{\kern0pt}} \qquad & (\isa{IH\isactrlsub {\isadigit{2}}}) 
      \end{alignedat}
    \end{equation*}

    Since the pointer is a simple predecessor pointer, the predicate \isa{scans\ {\isasymomega}\ k\ x{\isacharprime}{\kern0pt}\ x} holds and we also know that $x$ as well
    as $x'$ are well-formed bin items. Consequently, we obtain the following facts:

    \begin{equation*}
      \begin{alignedat}{2}
        & \isa{item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ x} \qquad & (a) \\
        & \isa{item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x} \qquad & (b) \\
        & \isa{item{\isacharunderscore}{\kern0pt}bullet\ x{\isacharprime}{\kern0pt}\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}bullet\ x} \qquad & (c) \\
        & \isa{next{\isacharunderscore}{\kern0pt}symbol\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ {\isacharparenleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}} \qquad & (d) \\
        & \isa{item{\isacharunderscore}{\kern0pt}origin\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}origin\ x} \qquad & (e) \\
        & \isa{item{\isacharunderscore}{\kern0pt}end\ x\ {\isacharequal}{\kern0pt}\ k} \qquad & (f) \\
        & \isa{item{\isacharunderscore}{\kern0pt}end\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}} \qquad & (g)
      \end{alignedat}
    \end{equation*}

    We first prove \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t}:

    \begin{equation*}
      \begin{alignedat}{2}
        & \isa{map\ root{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}Leaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}} & \\
        & \qquad = \isa{map\ root{\isacharunderscore}{\kern0pt}tree\ ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} \qquad & (1) \\
        & \qquad = \isa{take\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}bullet\ x{\isacharprime}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x{\isacharprime}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} \qquad & (2) \\
        & \qquad = \isa{take\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}bullet\ x{\isacharprime}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x{\isacharparenright}{\kern0pt}\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} \qquad & (3) \\
        & \qquad = \isa{take\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}bullet\ x{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x{\isacharparenright}{\kern0pt}} \qquad & (4)
      \end{alignedat}
    \end{equation*}

    (1) by definition.
    (2) by (\isa{IH\isactrlsub {\isadigit{1}}}).
    (3) by (b).
    (4) by (b,c,d).
    The statement \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t} follows by (a), using once more (\isa{IH\isactrlsub {\isadigit{1}}}) to
    prove that all subtrees are complete according to the grammar by definition of \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree}.

    To conclude the proof for the simple predecessor pointer, we prove the statement \isa{\mbox{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t}}:

    \begin{equation*}
      \begin{alignedat}{2}
        & \isa{yield{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}Branch\ N\ {\isacharparenleft}{\kern0pt}ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}Leaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}} & \\
        & \qquad = \isa{concat\ {\isacharparenleft}{\kern0pt}map\ yield{\isacharunderscore}{\kern0pt}tree\ ts{\isacharparenright}{\kern0pt}\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} \qquad & (1) \\
        & \qquad = \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isacharprime}{\kern0pt}{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isacharprime}{\kern0pt}{\isasymrangle}\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} \qquad & (2) \\
        & \qquad = \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isacharprime}{\kern0pt}{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isacharprime}{\kern0pt}\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isasymrangle}} \qquad & (3) \\
        & \qquad = \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isacharprime}{\kern0pt}\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isasymrangle}}  \qquad & (4) \\
        & \qquad = \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isasymrangle}} \qquad & (5)
      \end{alignedat}
    \end{equation*}

    (1) by definition.
    (2) by (\isa{IH\isactrlsub {\isadigit{2}}}). 
    (3) by (g) and the definition of \isa{slice}.
    (4) by (e).
    (5) by (f,g).

  \item \isa{pointer\ e\ {\isacharequal}{\kern0pt}\ PreRed\ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ ps}:
    The proof is similar in structure to the proof of the simple predecessor case. We only highlight
    the main differences. In contrast to only one recursive call for the predecessor item $x'$, we
    have another recursive call for the complete reduction item $y$. But we also have an additional
    induction hypothesis. The proofs of \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t} and \isa{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t}
    are analogous to the case above replacing \isa{Leaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}} with the branch obtained from
    the second recursive call. Statements similar to (a-g) hold since all items are well-formed and
    the predicate \isa{completes\ k\ x{\isacharprime}{\kern0pt}\ x\ y} is true.

\end{itemize}

\end{proof}%
\end{isamarkuptext}\isamarkuptrue%
%
\begin{isamarkuptext}%
Next we prove that, if the function \isa{build{\isacharunderscore}{\kern0pt}tree} returns a parse tree, it is a complete and
well-formed tree according to the grammar, the root of the tree is the start symbol of the grammar,
and the yield of the tree corresponds to the input. The subsequent corollary then proves that the theorem
in particular holds if we generate the bins using the algorithm of Chapter \ref{chap:04} if we adjust
the assumptions accordingly.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}root{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}tree{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}bins\ {\isasymG}\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}mono{\isacharunderscore}{\kern0pt}red{\isacharunderscore}{\kern0pt}ptrs\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbar}{\kern0pt}{\isasymomega}{\isacharbar}{\kern0pt}\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isasymomega}\ bs\ {\isacharequal}{\kern0pt}\ Some\ t{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t\ {\isasymand}\ root{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymSS}\ {\isasymG}\ {\isasymand}\ yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
\begin{proof}

The function \isa{build{\isacharunderscore}{\kern0pt}tree} searches the last bin for any finished items. Since it returns
a tree by assumption, it is successful, or finds a finished item $x$ at index $i$, and calls
the function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}\ i}. By assumption the input and the bins are
well-formed, we can discharge the assumptions of the previous two lemmas, obtain a tree \isa{t\ {\isacharequal}{\kern0pt}\ Branch\ N\ ts} and have:

$$\isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t\ {\isasymand}\ wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t}$$

Furthermore, the item $x$ is finished or its rule head is the start symbol of the grammar, it is complete, and
its origin and end respectively are $0$ and \isa{{\isacharbar}{\kern0pt}{\isasymomega}{\isacharbar}{\kern0pt}}. Due to the completeness and well-formedness
of the item \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t} implies \isa{wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t} and \isa{root{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymSS}\ {\isasymG}}.
From \isa{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t} we have \isa{yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isasymrangle}} by definition,
and consequently \isa{yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}}.

\end{proof}%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{corollary}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}root{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ t{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t\ {\isasymand}\ root{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymSS}\ {\isasymG}\ {\isasymand}\ yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
We conclude this section with the final theorem stating that the function \isa{build{\isacharunderscore}{\kern0pt}tree}
returns some parse tree if and only if there exists a derivation of the input from the start symbol
of the grammar, provided we generated the bins with the algorithm of Chapter \ref{chap:04}, and grammar
and input are well-formed.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ correctness{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}is{\isacharunderscore}{\kern0pt}sentence\ {\isasymG}\ {\isasymomega}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isasymexists}t{\isachardot}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ t{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ {\isasymG}\ {\isasymturnstile}\ {\isacharbrackleft}{\kern0pt}{\isasymSS}\ {\isasymG}{\isacharbrackright}{\kern0pt}\ {\isasymRightarrow}\isactrlsup {\isacharasterisk}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
\begin{proof}

The function \isa{build{\isacharunderscore}{\kern0pt}tree} searches the last bin for a finished item $x$.
It finds such an item and returns a parse tree if and only if the bins generated
by \isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}} are \isa{recognizing} which in turn holds if and only if
there exists a derivation of the input from the start symbol of the grammar by
lemma \isa{correctness{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list} using our assumptions.

\end{proof}%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsection{All Parse Trees \label{sec:parse-forest}%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
Computing a single parse tree is sufficient for unambiguous grammars, but an Earley parser - in its most general form -
can handle all context-free grammars. For ambiguous grammars there might exist multiple
parse trees for a specific input, there might even be exponentially many. One example of a highly ambiguous
grammar that produces exponentially many parse trees is our running example. To be precise, the number of
parse trees for an input $\omega = x + \dots + x$ is the Catalan number $C_n$ where $n-1$ is the
number of times the terminal $x$ occurs in \isa{{\isasymomega}}. It is well known that the $n$-th Catalan number can be expressed as
$C_n = \frac{1}{n+1} \binom{2n}{n}$ and thus grows asympotically at least exponentially. For example, the number of parse trees for an input \isa{{\isasymomega}} containing
$12$ times the terminal $x$ is already $C_{11} = 58786$. Thus, it is infeasible to compute all possible
parse trees in a naive fashion.

In the following we generalize the algorithm for a single parse tree to compute a representation of
all parse trees, or a parse forest. The key idea is to find a data structure that allows as much structural
sharing as possible between different parse trees. As an initial step, we make the following observation:
for two reduction triples $\isa{{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}\isactrlsub A{\isacharcomma}{\kern0pt}\ pre\isactrlsub A{\isacharcomma}{\kern0pt}\ red\isactrlsub A{\isacharparenright}{\kern0pt}}$ and $\isa{{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}\isactrlsub B{\isacharcomma}{\kern0pt}\ pre\isactrlsub B{\isacharcomma}{\kern0pt}\ red\isactrlsub B{\isacharparenright}{\kern0pt}}$ of an Earley item
we know that \isa{red\isactrlsub A\ {\isasymnoteq}\ red\isactrlsub B}, but it might be the case that \isa{k{\isacharprime}{\kern0pt}\isactrlsub A\ {\isacharequal}{\kern0pt}\ k{\isacharprime}{\kern0pt}\isactrlsub B} (which implies
\isa{pre\isactrlsub A\ {\isacharequal}{\kern0pt}\ pre\isactrlsub B} due to the set semantics of the bins). In other words, for different reduction
items, we might have the same predecessor item and thus can share the subtree representing the predecessor.

We define a data type \isa{forest} capturing this idea and representing parse forests. Consider an arbitrary production rule
$S \rightarrow \, AxB$ for non-terminals $S, A, B$ and terminal $x$. A branch of a single tree
contains a list of length $3$ containing the three subtrees $t_A$, $t_x$, and $t_B$ corresponding to
the three symbols $A$, $x$, and $B$. For a parse forest we still have a list of length $3$, but each element is now
again a list of forests sharing subforests derived from the same non-terminal. For example, the list of subforests of a branch
might look like \isa{{\isacharbrackleft}{\kern0pt}{\isacharbrackleft}{\kern0pt}f\isactrlsub A\isactrlsub {\isadigit{1}}{\isacharcomma}{\kern0pt}\ f\isactrlsub A\isactrlsub {\isadigit{2}}{\isacharbrackright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}f\isactrlsub x{\isacharbrackright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}f\isactrlsub B{\isacharbrackright}{\kern0pt}{\isacharbrackright}{\kern0pt}} if there are two possible parse forests derived from
the non-terminal $A$, and one parse forest derived from the symbols $x$ and $B$ each. Note that if the subforest is a forest leaf than the list contains just this
single leaf, or there never occurs a situation like \isa{{\isacharbrackleft}{\kern0pt}{\isacharbrackleft}{\kern0pt}f\isactrlsub A{\isacharbrackright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}f\isactrlsub x\isactrlsub {\isadigit{1}}{\isacharcomma}{\kern0pt}\ f\isactrlsub x\isactrlsub {\isadigit{2}}{\isacharbrackright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}f\isactrlsub B{\isacharbrackright}{\kern0pt}{\isacharbrackright}{\kern0pt}}.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{datatype}\isamarkupfalse%
\ {\isacharprime}{\kern0pt}a\ forest\ {\isacharequal}{\kern0pt}\isanewline
\ \ FLeaf\ {\isacharprime}{\kern0pt}a\isanewline
{\isacharbar}{\kern0pt}\ FBranch\ {\isacharprime}{\kern0pt}a\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ forest\ list\ list{\isachardoublequoteclose}%
\begin{isamarkuptext}%
We introduce an abstraction function \isa{trees} computing all possible parse trees for a given parse forest.
For a forest leaf this is trivial, for a forest branch we first apply the function
\isa{trees} recursively for all subforests, then concatenate the results for each subforest, and finally create a tree branch
for each of the possible combinations of subtrees. E.g. for the subforests
\isa{{\isacharbrackleft}{\kern0pt}{\isacharbrackleft}{\kern0pt}f\isactrlsub A\isactrlsub {\isadigit{1}}{\isacharcomma}{\kern0pt}\ f\isactrlsub A\isactrlsub {\isadigit{2}}{\isacharbrackright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}f\isactrlsub x{\isacharbrackright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}f\isactrlsub B{\isacharbrackright}{\kern0pt}{\isacharbrackright}{\kern0pt}} we might obtain the possible subtrees \isa{{\isacharbrackleft}{\kern0pt}{\isacharbrackleft}{\kern0pt}t\isactrlsub A\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{1}}{\isacharcomma}{\kern0pt}\ t\isactrlsub A\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{2}}{\isacharcomma}{\kern0pt}\ t\isactrlsub A\isactrlsub {\isadigit{2}}{\isacharbrackright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}t\isactrlsub x{\isacharbrackright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}t\isactrlsub B{\isacharbrackright}{\kern0pt}{\isacharbrackright}{\kern0pt}} if the
forest \isa{f\isactrlsub A\isactrlsub {\isadigit{1}}} yields two parse trees \isa{t\isactrlsub A\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{1}}} and \isa{t\isactrlsub A\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{2}}} and every other forest yields only
a single tree. The three possible combinations of subtrees for the non-terminal $N$ are then: \isa{{\isacharbrackleft}{\kern0pt}t\isactrlsub A\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{1}}{\isacharcomma}{\kern0pt}\ t\isactrlsub x{\isacharcomma}{\kern0pt}\ t\isactrlsub B{\isacharbrackright}{\kern0pt}}, \isa{{\isacharbrackleft}{\kern0pt}t\isactrlsub A\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{2}}{\isacharcomma}{\kern0pt}\ t\isactrlsub x{\isacharcomma}{\kern0pt}\ t\isactrlsub B{\isacharbrackright}{\kern0pt}},
and \isa{{\isacharbrackleft}{\kern0pt}t\isactrlsub A\isactrlsub {\isadigit{2}}{\isacharcomma}{\kern0pt}\ t\isactrlsub x{\isacharcomma}{\kern0pt}\ t\isactrlsub B{\isacharbrackright}{\kern0pt}}.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{fun}\isamarkupfalse%
\ combinations\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ list\ list\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ list\ list{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}combinations\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}combinations\ {\isacharparenleft}{\kern0pt}xs{\isacharhash}{\kern0pt}xss{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}\ x{\isacharhash}{\kern0pt}cs\ {\isachardot}{\kern0pt}\ x\ {\isacharless}{\kern0pt}{\isacharminus}{\kern0pt}\ xs{\isacharcomma}{\kern0pt}\ cs\ {\isacharless}{\kern0pt}{\isacharminus}{\kern0pt}\ combinations\ xss\ {\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ trees\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ forest\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ list{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}trees\ {\isacharparenleft}{\kern0pt}FLeaf\ a{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}Leaf\ a{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}trees\ {\isacharparenleft}{\kern0pt}FBranch\ N\ fss{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ let\ tss\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}fs{\isachardot}{\kern0pt}\ concat\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}f{\isachardot}{\kern0pt}\ trees\ f{\isacharparenright}{\kern0pt}\ fs{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ fss{\isacharparenright}{\kern0pt}\ in\isanewline
\ \ \ \ map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}ts{\isachardot}{\kern0pt}\ Branch\ N\ ts{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}combinations\ tss{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{A Parse Forest Algorithm%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
We define two auxiliary functions \isa{group{\isacharunderscore}{\kern0pt}by} and \isa{insert{\isacharunderscore}{\kern0pt}group} grouping a list of values \isa{xs} according to a key-mapping $K$
and a value-mapping $V$ by key. E.g. for the list of tuples \isa{xs\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharparenleft}{\kern0pt}{\isadigit{1}}{\isacharcomma}{\kern0pt}\ a{\isacharparenright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isadigit{2}}{\isacharcomma}{\kern0pt}\ b{\isacharparenright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isadigit{1}}{\isacharcomma}{\kern0pt}\ c{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} and
mappings \isa{K\ {\isacharequal}{\kern0pt}\ fst} and \isa{V\ {\isacharequal}{\kern0pt}\ snd} we obtain the association list \isa{{\isacharbrackleft}{\kern0pt}{\isacharparenleft}{\kern0pt}{\isadigit{1}}{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}a{\isacharcomma}{\kern0pt}\ c{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharcomma}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isadigit{2}}{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}b{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}}.
\newpage%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{fun}\isamarkupfalse%
\ insert{\isacharunderscore}{\kern0pt}group\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}k{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}v{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}k\ {\isasymtimes}\ {\isacharprime}{\kern0pt}v\ list{\isacharparenright}{\kern0pt}\ list\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}k\ {\isasymtimes}\ {\isacharprime}{\kern0pt}v\ list{\isacharparenright}{\kern0pt}\ list{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}insert{\isacharunderscore}{\kern0pt}group\ K\ V\ a\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharparenleft}{\kern0pt}K\ a{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}V\ a{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}insert{\isacharunderscore}{\kern0pt}group\ K\ V\ a\ {\isacharparenleft}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharcomma}{\kern0pt}\ vs{\isacharparenright}{\kern0pt}{\isacharhash}{\kern0pt}xs{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ if\ K\ a\ {\isacharequal}{\kern0pt}\ k\ then\ {\isacharparenleft}{\kern0pt}k{\isacharcomma}{\kern0pt}\ V\ a\ {\isacharhash}{\kern0pt}\ vs{\isacharparenright}{\kern0pt}\ {\isacharhash}{\kern0pt}\ xs\isanewline
\ \ \ \ else\ {\isacharparenleft}{\kern0pt}k{\isacharcomma}{\kern0pt}\ vs{\isacharparenright}{\kern0pt}\ {\isacharhash}{\kern0pt}\ insert{\isacharunderscore}{\kern0pt}group\ K\ V\ a\ xs\ \ \isanewline
\ \ {\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ group{\isacharunderscore}{\kern0pt}by\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}k{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}v{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ list\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}k\ {\isasymtimes}\ {\isacharprime}{\kern0pt}v\ list{\isacharparenright}{\kern0pt}\ list{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}group{\isacharunderscore}{\kern0pt}by\ K\ V\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}group{\isacharunderscore}{\kern0pt}by\ K\ V\ {\isacharparenleft}{\kern0pt}x{\isacharhash}{\kern0pt}xs{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ insert{\isacharunderscore}{\kern0pt}group\ K\ V\ x\ {\isacharparenleft}{\kern0pt}group{\isacharunderscore}{\kern0pt}by\ K\ V\ xs{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
Next we implement the function \isa{build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}}. It takes as arguments the bins \isa{bs}, the indices of the bin and
item, $k$ respectively $i$, and a set of natural numbers $I$, and returns an optional list of parse forests.
There are two things to note here: the return type and the argument $I$. One might expect that we can return
a single parse forest and not a list of forests. This is not the case. Although we are sharing subforests for two distinct reduction triples
\isa{{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}\isactrlsub A{\isacharcomma}{\kern0pt}\ pre\isactrlsub A{\isacharcomma}{\kern0pt}\ red\isactrlsub A{\isacharparenright}{\kern0pt}} and \isa{{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}\isactrlsub B{\isacharcomma}{\kern0pt}\ pre\isactrlsub B{\isacharcomma}{\kern0pt}\ red\isactrlsub B{\isacharparenright}{\kern0pt}} if \isa{\mbox{{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}\isactrlsub A{\isacharcomma}{\kern0pt}\ pre\isactrlsub A{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}\isactrlsub B{\isacharcomma}{\kern0pt}\ pre\isactrlsub B{\isacharparenright}{\kern0pt}}}, we
can not share the subforests if the predecessor items are distinct, and hence need to return two distinct forests in this case. Furthermore, the algorithm returns an
optional value since the function might not terminate if the pointers are not sound as it was the case
for function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}}. But unfortunately, this time around the situation is even worse:
even for sound pointers the function \isa{build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}} might not terminate.
As explained in Subsection \ref{q}, the bins computed by the algorithm \isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list} contain
cyclic reduction pointers for cyclic grammars, and thus naively following all reduction pointers might lead
to non-termination. To ensure the termination of the algorithm we keep track of the items the algorithm
already visited in a single bin by means of the additional argument $I$ representing the indices
of the previous function calls in the same bin. The algorithm proceeds as follows:

Let $e$ denote the $i$-th item in the $k$-th bin. If the pointer of $e$ is
a null pointer the forest algorithm proceeds analogously to the tree algorithm, constructing an initially
empty forest branch.

For the simple predecessor case it calls itself recursively for the previous bin
$k-1$, predecessor index \isa{pre}, and initializes the set of visited indices for bin $k-1$ with
the single index \isa{pre} to indicate that the computation for this index has already been started, obtaining a list of optional predecessor forests. It then appends
to the list of subforests of each of these predecessor forests a new forest leaf containing the terminal symbol at
index $k-1$ of the input. Note the monadic do-notation for the option monad, and the use
of the function \isa{those} that converts a list of optional values into an optional list of values
if and only if each of the optional values is present, or not none.

In the case that the algorithm
encounters a predecessor/reduction pointer it first makes sure to not enter a cycle of reductions
by discarding any reduction indices that are contained in $I$ and thus the algorithm has already started to process in earlier
recursive calls. It then groups the reduction triples by predecessor. Subsequently, for each tuple of predecessor
($k'$ and \isa{pre}) and reduction indices \isa{reds} it proceeds as follows. It first calls itself once recursively
for the predecessor, initializing the set $I$ as \isa{{\isacharbraceleft}{\kern0pt}pre{\isacharbraceright}{\kern0pt}}, and obtaining a list of predecessor
forests. Then it executes one recursive call for each reduction index \isa{red\ {\isasymin}\ set\ reds}
in the current bin $k$ making sure to mark the index \isa{red} as already visited by adding it to $I$.
Finally, it appends to the list of subforests of each predecessor forest the list of reduction forests
computed in the previous step.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{partial{\isacharunderscore}{\kern0pt}function}\isamarkupfalse%
\ {\isacharparenleft}{\kern0pt}option{\isacharparenright}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ nat\ set\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ forest\ list\ option{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ I\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ let\ e\ {\isacharequal}{\kern0pt}\ bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i\ in\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ case\ pointer\ e\ of\isanewline
\ \ \ \ \ \ Null\ {\isasymRightarrow}\ Some\ {\isacharparenleft}{\kern0pt}{\isacharbrackleft}{\kern0pt}FBranch\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ {\isacharparenleft}{\kern0pt}item\ e{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ {\isacharbar}{\kern0pt}\ Pre\ pre\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ do\ {\isacharbraceleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ pres\ {\isasymleftarrow}\ build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}\ pre\ {\isacharbraceleft}{\kern0pt}pre{\isacharbraceright}{\kern0pt}{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ those\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}f{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ case\ f\ of\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ FBranch\ N\ fss\ {\isasymRightarrow}\ Some\ {\isacharparenleft}{\kern0pt}FBranch\ N\ {\isacharparenleft}{\kern0pt}fss\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackleft}{\kern0pt}FLeaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}{\isacharbang}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ {\isacharbar}{\kern0pt}\ {\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ None\isanewline
\ \ \ \ \ \ \ \ \ \ {\isacharparenright}{\kern0pt}\ pres{\isacharparenright}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ {\isacharbar}{\kern0pt}\ PreRed\ p\ ps\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ let\ ps{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ filter\ {\isacharparenleft}{\kern0pt}{\isasymlambda}{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\ red\ {\isasymnotin}\ I{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}p{\isacharhash}{\kern0pt}ps{\isacharparenright}{\kern0pt}\ in\isanewline
\ \ \ \ \ \ \ \ let\ gs\ {\isacharequal}{\kern0pt}\ group{\isacharunderscore}{\kern0pt}by\ {\isacharparenleft}{\kern0pt}{\isasymlambda}{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isasymlambda}{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ ps{\isacharprime}{\kern0pt}\ in\isanewline
\ \ \ \ \ \ \ \ map{\isacharunderscore}{\kern0pt}option\ concat\ {\isacharparenleft}{\kern0pt}those\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}{\isacharparenleft}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharparenright}{\kern0pt}{\isacharcomma}{\kern0pt}\ reds{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ do\ {\isacharbraceleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ pres\ {\isasymleftarrow}\ build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k{\isacharprime}{\kern0pt}\ pre\ {\isacharbraceleft}{\kern0pt}pre{\isacharbraceright}{\kern0pt}{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ rss\ {\isasymleftarrow}\ those\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}red{\isachardot}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ red\ {\isacharparenleft}{\kern0pt}I\ {\isasymunion}\ {\isacharbraceleft}{\kern0pt}red{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ reds{\isacharparenright}{\kern0pt}{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ those\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}f{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ case\ f\ of\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FBranch\ N\ fss\ {\isasymRightarrow}\ Some\ {\isacharparenleft}{\kern0pt}FBranch\ N\ {\isacharparenleft}{\kern0pt}fss\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}concat\ rss{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isacharbar}{\kern0pt}\ {\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ None\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ {\isacharparenright}{\kern0pt}\ pres{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ {\isacharbraceright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ {\isacharparenright}{\kern0pt}\ gs{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\begin{isamarkuptext}%
The function \isa{build{\isacharunderscore}{\kern0pt}forests} is then defined analogously to the function \isa{build{\isacharunderscore}{\kern0pt}tree}.
The only difference is the use of the function \isa{those} to obtain an optional list of lists of
forests for all finished items in the last bin, and the subsequent use of \isa{map{\isacharunderscore}{\kern0pt}option} and \isa{concat}.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}forests\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ cfg\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ forest\ list\ option{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}forests\ {\isasymG}\ {\isasymomega}\ bs\ {\isasymequiv}\isanewline
\ \ \ \ let\ k\ {\isacharequal}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}\ in\isanewline
\ \ \ \ let\ finished\ {\isacharequal}{\kern0pt}\ filter{\isacharunderscore}{\kern0pt}with{\isacharunderscore}{\kern0pt}index\ {\isacharparenleft}{\kern0pt}{\isasymlambda}x{\isachardot}{\kern0pt}\ is{\isacharunderscore}{\kern0pt}finished\ {\isasymG}\ {\isasymomega}\ x{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}items\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ in\isanewline
\ \ \ \ map{\isacharunderscore}{\kern0pt}option\ concat\ {\isacharparenleft}{\kern0pt}those\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}{\isacharparenleft}{\kern0pt}{\isacharunderscore}{\kern0pt}{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ {\isacharbraceleft}{\kern0pt}i{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}\ finished{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Termination%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
Similarly to the single tree algorithm we need to define the well-formedess of the input and a suitable
measure for the forest algorithm to prove an applicable induction schema (\textit{forest induction}) by
complete induction on the measure. An input quintuplet \isa{\mbox{{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharcomma}{\kern0pt}\ I{\isacharparenright}{\kern0pt}}} is well-formed if
the pointers are sound, the indices $k$ and $i$ are within their respective bounds, and the set of already
visited indices $I$ contains the current index $i$ and only consists of indices bounded by the size of the current bin $k$.
As termination measure we count the number of items in the first $k$ bins minus the indices the algorithm
already visited in the $k$-th bin, or the contents of $I$. Thus, if the algorithm calls itself recursively
for a predecessor, either in bin $k-1$ or $k'$ where $k' < k$, the measure reduces by at least the difference
between the size of the current bin $k$ and the cardinality of $I$ (plus one, since the new set $I$ contains the index \isa{pre}).
In the case that the algorithm calls itself recursively for a reduction pointer \isa{red}, the measure decreases by exactly
one, since the algorithm adds \isa{red} to the set of already visited indices $I$ and it has not encountered this index beforehand.

To summarize: if the algorithm encounters a null pointer it terminates immediately.
For predecessor pointers it calls itself recursively in a bin with a strictly smaller index, and for chains of reduction
pointers it visits each index of the current bin at most once.

We then prove by \textit{forest induction} that the function \isa{build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}} always terminates
with some list of forests containing only forest branches for well-formed input.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}forest{\isacharunderscore}{\kern0pt}input\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ bins\ {\isasymtimes}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat\ set{\isacharparenright}{\kern0pt}\ set{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}forest{\isacharunderscore}{\kern0pt}input\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}\ {\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharcomma}{\kern0pt}\ I{\isacharparenright}{\kern0pt}\ {\isacharbar}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ I{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs\ {\isasymand}\ k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isasymand}\ i\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbar}{\kern0pt}\ {\isasymand}\ i\ {\isasymin}\ I\ {\isasymand}\ I\ {\isasymsubseteq}\ {\isacharbraceleft}{\kern0pt}{\isadigit{0}}{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}{\isacharless}{\kern0pt}{\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbar}{\kern0pt}{\isacharbraceright}{\kern0pt}\ {\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}forest{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}measure\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ bins\ {\isasymtimes}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat\ set{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ nat{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}forest{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}measure\ {\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharcomma}{\kern0pt}\ I{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ foldl\ {\isacharparenleft}{\kern0pt}{\isacharplus}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isadigit{0}}\ {\isacharparenleft}{\kern0pt}map\ length\ {\isacharparenleft}{\kern0pt}take\ {\isacharparenleft}{\kern0pt}k{\isacharplus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}\ bs{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharminus}{\kern0pt}\ card\ I{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}termination{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharcomma}{\kern0pt}\ I{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}forest{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymexists}fs{\isachardot}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ I\ {\isacharequal}{\kern0pt}\ Some\ fs\ {\isasymand}\ {\isacharparenleft}{\kern0pt}{\isasymforall}f\ {\isasymin}\ set\ fs{\isachardot}{\kern0pt}\ {\isasymexists}N\ fss{\isachardot}{\kern0pt}\ f\ {\isacharequal}{\kern0pt}\ FBranch\ N\ fss{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
At this point, one might wonder if the argument $I$ is really needed. The problem regarding non-termination
are the cyclic reduction pointers. In theory we could modify the algorithm of Chapter \ref{chap:04} to not
add any cyclic pointers at all to the bins, prove an according lemma, and require non-cyclic pointers
for the well-formedness of the input of the forest algorithm. Subsequently, we could remove the - no longer
needed - argument $I$ from the function \isa{build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}} and adjust the implementation accordingly.

But a problem of technical nature arises while trying to prove the \textit{forest induction} schema.
We need to define a suitable measure capturing the termination argument in terms of the input, or a function
of the form $('a \, \mathit{bins} \times 'a \, \mathit{sentential} \times \mathit{nat} \times \mathit{nat}) \Rightarrow \, \mathit{nat}$.
But we cannot express the termination argument just in terms of the current input \isa{\mbox{{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}}}, but need access to
the history of recursive calls to argue that - for non-cyclic pointers - the algorithm calls itself
at most once for each index in the current bin $k$ during chains of reductions. Hence, we need to reintroduce
the argument $I$ of already visited indices or an equivalent argument. Note that this still simplifies
the function \isa{build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}} slightly due to the fact that we no longer need to filter the list
of reduction pointers, but comes at the cost of computing cycles of reduction pointers in the algorithm
of Chapter \ref{chap:04}. Additionally, the bins only contain cyclic pointers if the grammar itself is
cyclic and hence not adding any cyclic pointers in the first place could be considered incorrect.

In summary, the - already visited indices - argument $I$ serves two purposes: checking for pointer cycles while
constructing parse forests and expressing the termination argument of the algorithm.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Soundness%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
The following four lemmas prove soundness of the functions \isa{build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}} and \isa{build{\isacharunderscore}{\kern0pt}forests}.
The proof are analogous to the corresponding proofs for the functions \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}} and \isa{build{\isacharunderscore}{\kern0pt}tree},
replacing \textit{tree induction} with \textit{forest induction}. We might add that although the forest algorithm
is only a slight generalization of the tree algorithm and hence one might suspect that the proofs should generalize
easily, this is unfortunately not the case. The proofs are rather unpleasant and cumbersome due to the complexity
that occurs from the interplay of the option monad (and actually the list monad we are working with but not using explicit do notation for), functions \isa{those}, \isa{map{\isacharunderscore}{\kern0pt}option},
\isa{concat}, and the quite involved definition of the abstraction function \isa{trees}. We refrain from
presenting any proofs in detail.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharcomma}{\kern0pt}\ I{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}forest{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}bins\ {\isasymG}\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ I\ {\isacharequal}{\kern0pt}\ Some\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}f\ {\isasymin}\ set\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}t\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}trees\ f{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ t\ {\isasymand}\ wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ t{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}root{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}forests{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}bins\ {\isasymG}\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbar}{\kern0pt}{\isasymomega}{\isacharbar}{\kern0pt}\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}forests\ {\isasymG}\ {\isasymomega}\ bs\ {\isacharequal}{\kern0pt}\ Some\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}f\ {\isasymin}\ set\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}t\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}trees\ f{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t\ {\isasymand}\ root{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymSS}\ {\isasymG}\ {\isasymand}\ yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{corollary}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}root{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}forests{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}forests\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}f\ {\isasymin}\ set\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}t\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}trees\ f{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t\ {\isasymand}\ root{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymSS}\ {\isasymG}\ {\isasymand}\ yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ soundness{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}forests{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}is{\isacharunderscore}{\kern0pt}sentence\ {\isasymG}\ {\isasymomega}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}forests\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}f\ {\isasymin}\ set\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}t\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}trees\ f{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymG}\ {\isasymturnstile}\ {\isacharbrackleft}{\kern0pt}{\isasymSS}\ {\isasymG}{\isacharbrackright}{\kern0pt}\ {\isasymRightarrow}\isactrlsup {\isacharasterisk}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Completeness%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
At this point we would like to prove that the forest algorithm indeed computes all possible parse trees.
But before we can attempt such a proof we first need to define completeness. Recall the
cyclic grammer $A ::= x \, | \, B, \, B ::= A$. There exist an infinite amount of parse trees for the
input $\omega = x$. Although there certainly exist data structures modeling parse forests that enable an representation
of an infinite amount of parse trees, our data type \isa{forest} is not expressive enough. Note that,
since we assume a finite grammar, there necessarily has to exist a cycle in the grammar if there exist
an infinite amount of parse trees. The algorithm \isa{build{\isacharunderscore}{\kern0pt}forests{\isacharprime}{\kern0pt}} does not complete any cycles and
thus returns only those parse trees up to the depth of the cycle in the grammar, or the parse trees
$A \, \text{--} \, x$ and $A \, \text{--} \, B \, \text{--} \, A \, \text{--} \, x$ for the given cyclic grammar. In conclusion,
we can only prove the completeness of the algorithm for non-cyclic grammars.

But, as already mentioned in the introduction for this chapter, we decided against formally proving completeness for the parse forest algorithm. The
reasoning is twofold. The completeness proof is far from trivial and exceeded the scope of this thesis.
Secondly, the algorithm is only of theoretical interest and far from being practical due to its poor performance.
The simple sharing of subforests for identical predecessor items is one optimization over the naive approach, but unfortunately
not enough to make the algorithm practical, as some experimentation suggests. We would need to introduce
further performance improvements. One obvious improvement is to use more structural sharing of subforests.
At the moment the algorithm always appends new lists of subforests. We can avoid copying the current list
of subforests if we preprend instead of append, and finally reverse the subforests for complete items. 
Another concern is the number of executed recursive calls. As implemented, the algorithm might call itself recursively more than
once for the same Earley item or identical bins and item indices. This occurs for example if we have
two different predecessor items but the same reduction item, e.g. items of the form $A \rightarrow \, \alpha_A C \bullet \beta_A, i_A, j$,
$B \rightarrow \, \alpha_B C \bullet \beta_B, i_B, j$, and $C \rightarrow \, \gamma \bullet, i_C, j$. The algorithm calls itself at least twice for
the complete reduction item and thus also more than once for any items that can be reached from that item recursively. We could avoid repeated recursive calls using
common memoization techniques. But some experiments with both performance improvements lead us to the following sentiment: the result is a
highly complex algorithm with still subpar performance. 

We can conclude: the straightforward generalization from the single parse tree algorithm to a parse
forest algorithm is probably correct (at least sound). Nonetheless, we abandon this approach due to the
awkwardness of the termination proof which requires and additional argument that cannot be fully eliminated
due to not only but also including technical reasons. The second reason is the poor performance of the algorithm that we observed during some experimentation.
This can be remedied to some degree by the improvements sketched above, but has other downsides like a convoluted
and unnecessarily complex implementation.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsection{A Word on Parse Forests \label{sec:word}%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
We have two main decisions to make while choosing an appropriate algorithm and data structure for implementing
an Earley parser. (1) should the construction of a parse forest be intertwined with the generation of the
Earley items or not. In other words: do we want a single or two phase algorithm. (2) and most importantly,
we need to choose an appropriate data structure for a parse forest that can represent all parse trees and
be constructed in optimally cubic space and time.

One of the main lessons of Section \ref{sec:parse-forest} is that we should prefer a single phase over a two
phase algorithm. Any two phase algorithm must store some sort of data structure to indicate the origin
of each Earley item generated during the first phase. In the second phase it then walks this data structure while
constructing a parse forest and encounters the same complications regarding termination as the algorithm
of the previous section. In contrast, a single phase algorithm that constructs a parse forest while
generating the bins can be embedded into the algorithm of Chapter \ref{chapter:3}. Consequently, it is tail-recursive, 
and thus can return a plain and not an optional value. Moreover, it can reuse the termination argument that the
number of Earley items is finite, and hence avoid introducing any superfluous arguments that are only needed
to prove the termination of the algorithm.

Regarding the choice of an appropriate data structure for parse forests: the most well-known data structure for representing all possible derivations, a shared packed parse
forest (SPPF), was introduced by Tomita \cite{Tomita:1985}. The nodes of a SPPF are labelled by
triples \isa{{\isacharparenleft}{\kern0pt}N{\isacharcomma}{\kern0pt}\ i{\isacharcomma}{\kern0pt}\ j{\isacharparenright}{\kern0pt}} where \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}i{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}j{\isasymrangle}} is the subsequence matched by the non-terminal $N$.
A SPPF utilizes two types of sharing. Nodes that have the same tree below them are shared. Additionally,
the SPPF might contain so-called packed nodes representing a family of children. Each child stands for
a different derivation of the same subsequence \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}i{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}j{\isasymrangle}} from the same non-terminal but following an
alternate production rule. Scott \cite{Scott:2008} adjusts the SPPF data structure of Tomita slightly
and presents two algorithms - one single and one two phase - based on Earley's recognizer that are of
worst case cubic space and time. Both approaches can be implemented on top of our implementation of
the Earley recognizer of Chapter \ref{chapter:3}, although we strongly advise for the single phase algorithm
due to the argument stated above. We did not attempt to formalize the algorithm of Scott since the
implementation is rather complex - we already glossed over some important details of the SPPF data structure
that are necessary to achieve the optimal cubic running time - and hence out of scope for this thesis.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\end{isabellebody}%
\endinput
%:%file=05_Earley_Parser.tex%:%
%:%24=9%:%
%:%36=12%:%
%:%37=13%:%
%:%38=14%:%
%:%39=15%:%
%:%40=16%:%
%:%41=17%:%
%:%42=18%:%
%:%43=19%:%
%:%44=20%:%
%:%45=21%:%
%:%46=22%:%
%:%47=23%:%
%:%48=24%:%
%:%49=25%:%
%:%50=26%:%
%:%51=27%:%
%:%52=28%:%
%:%53=29%:%
%:%54=30%:%
%:%55=31%:%
%:%56=32%:%
%:%57=33%:%
%:%58=34%:%
%:%59=35%:%
%:%60=36%:%
%:%61=37%:%
%:%62=38%:%
%:%63=39%:%
%:%64=40%:%
%:%65=41%:%
%:%66=42%:%
%:%67=43%:%
%:%68=44%:%
%:%69=45%:%
%:%70=46%:%
%:%71=47%:%
%:%72=48%:%
%:%73=49%:%
%:%74=50%:%
%:%75=51%:%
%:%76=52%:%
%:%77=53%:%
%:%78=54%:%
%:%79=55%:%
%:%80=56%:%
%:%81=57%:%
%:%82=58%:%
%:%83=59%:%
%:%84=60%:%
%:%85=61%:%
%:%86=62%:%
%:%87=63%:%
%:%88=64%:%
%:%89=65%:%
%:%90=66%:%
%:%91=67%:%
%:%92=68%:%
%:%93=69%:%
%:%94=70%:%
%:%95=71%:%
%:%104=74%:%
%:%116=77%:%
%:%117=78%:%
%:%118=79%:%
%:%119=80%:%
%:%120=81%:%
%:%122=84%:%
%:%123=84%:%
%:%124=85%:%
%:%125=86%:%
%:%126=87%:%
%:%127=88%:%
%:%128=88%:%
%:%129=89%:%
%:%130=90%:%
%:%131=91%:%
%:%132=92%:%
%:%133=92%:%
%:%134=93%:%
%:%135=94%:%
%:%137=97%:%
%:%138=98%:%
%:%139=99%:%
%:%140=100%:%
%:%141=101%:%
%:%142=102%:%
%:%143=103%:%
%:%144=104%:%
%:%145=105%:%
%:%146=106%:%
%:%147=107%:%
%:%148=108%:%
%:%149=109%:%
%:%150=110%:%
%:%151=111%:%
%:%152=112%:%
%:%154=115%:%
%:%155=115%:%
%:%156=116%:%
%:%157=117%:%
%:%159=119%:%
%:%160=120%:%
%:%161=121%:%
%:%162=121%:%
%:%163=122%:%
%:%164=123%:%
%:%166=125%:%
%:%167=126%:%
%:%168=127%:%
%:%169=127%:%
%:%170=128%:%
%:%177=131%:%
%:%189=134%:%
%:%190=135%:%
%:%191=136%:%
%:%192=137%:%
%:%193=138%:%
%:%194=139%:%
%:%195=140%:%
%:%196=141%:%
%:%197=142%:%
%:%198=143%:%
%:%199=144%:%
%:%200=145%:%
%:%201=146%:%
%:%202=147%:%
%:%203=148%:%
%:%204=149%:%
%:%205=150%:%
%:%206=151%:%
%:%207=152%:%
%:%208=153%:%
%:%209=154%:%
%:%210=155%:%
%:%211=156%:%
%:%212=157%:%
%:%213=158%:%
%:%215=161%:%
%:%216=161%:%
%:%217=162%:%
%:%218=163%:%
%:%219=164%:%
%:%220=164%:%
%:%221=165%:%
%:%222=166%:%
%:%223=167%:%
%:%224=167%:%
%:%225=168%:%
%:%226=169%:%
%:%227=170%:%
%:%228=170%:%
%:%229=171%:%
%:%231=173%:%
%:%232=174%:%
%:%233=175%:%
%:%234=175%:%
%:%235=176%:%
%:%236=177%:%
%:%237=178%:%
%:%238=179%:%
%:%239=179%:%
%:%240=180%:%
%:%242=182%:%
%:%243=183%:%
%:%244=184%:%
%:%245=184%:%
%:%246=185%:%
%:%249=189%:%
%:%250=190%:%
%:%251=191%:%
%:%252=192%:%
%:%253=193%:%
%:%254=194%:%
%:%255=195%:%
%:%256=196%:%
%:%257=197%:%
%:%258=198%:%
%:%259=199%:%
%:%261=202%:%
%:%262=202%:%
%:%263=203%:%
%:%264=204%:%
%:%265=205%:%
%:%266=206%:%
%:%267=207%:%
%:%268=208%:%
%:%269=209%:%
%:%286=216%:%
%:%287=216%:%
%:%288=217%:%
%:%289=218%:%
%:%290=219%:%
%:%291=220%:%
%:%292=221%:%
%:%293=222%:%
%:%310=229%:%
%:%311=229%:%
%:%312=230%:%
%:%313=231%:%
%:%314=232%:%
%:%315=233%:%
%:%316=234%:%
%:%333=241%:%
%:%334=241%:%
%:%335=242%:%
%:%336=243%:%
%:%337=244%:%
%:%338=245%:%
%:%339=246%:%
%:%356=253%:%
%:%357=253%:%
%:%358=254%:%
%:%375=261%:%
%:%376=261%:%
%:%377=262%:%
%:%378=263%:%
%:%379=264%:%
%:%380=265%:%
%:%397=272%:%
%:%398=272%:%
%:%399=273%:%
%:%400=274%:%
%:%401=275%:%
%:%421=281%:%
%:%433=284%:%
%:%434=285%:%
%:%435=286%:%
%:%436=287%:%
%:%437=288%:%
%:%438=289%:%
%:%439=290%:%
%:%440=291%:%
%:%441=292%:%
%:%442=293%:%
%:%443=294%:%
%:%444=295%:%
%:%445=296%:%
%:%446=297%:%
%:%447=298%:%
%:%448=299%:%
%:%449=300%:%
%:%450=301%:%
%:%451=302%:%
%:%452=303%:%
%:%453=304%:%
%:%454=305%:%
%:%455=306%:%
%:%456=307%:%
%:%457=308%:%
%:%458=309%:%
%:%460=312%:%
%:%461=312%:%
%:%462=313%:%
%:%483=335%:%
%:%484=336%:%
%:%485=337%:%
%:%486=338%:%
%:%487=339%:%
%:%488=340%:%
%:%489=341%:%
%:%491=344%:%
%:%492=344%:%
%:%493=345%:%
%:%504=352%:%
%:%516=355%:%
%:%517=356%:%
%:%518=357%:%
%:%519=358%:%
%:%520=359%:%
%:%521=360%:%
%:%522=361%:%
%:%523=362%:%
%:%524=363%:%
%:%525=364%:%
%:%526=365%:%
%:%527=366%:%
%:%528=367%:%
%:%529=368%:%
%:%530=369%:%
%:%531=370%:%
%:%532=371%:%
%:%533=372%:%
%:%534=373%:%
%:%535=374%:%
%:%536=375%:%
%:%537=376%:%
%:%538=377%:%
%:%539=378%:%
%:%540=379%:%
%:%541=380%:%
%:%542=381%:%
%:%543=382%:%
%:%544=383%:%
%:%545=384%:%
%:%546=385%:%
%:%547=386%:%
%:%548=387%:%
%:%549=388%:%
%:%550=389%:%
%:%551=390%:%
%:%552=391%:%
%:%553=392%:%
%:%554=393%:%
%:%555=394%:%
%:%556=395%:%
%:%557=396%:%
%:%558=397%:%
%:%559=398%:%
%:%560=399%:%
%:%561=400%:%
%:%563=403%:%
%:%564=403%:%
%:%565=404%:%
%:%568=408%:%
%:%569=409%:%
%:%570=410%:%
%:%571=411%:%
%:%575=415%:%
%:%576=416%:%
%:%577=417%:%
%:%578=418%:%
%:%579=419%:%
%:%580=420%:%
%:%581=421%:%
%:%582=422%:%
%:%583=423%:%
%:%585=426%:%
%:%586=426%:%
%:%587=427%:%
%:%588=428%:%
%:%589=429%:%
%:%590=429%:%
%:%591=430%:%
%:%594=434%:%
%:%595=435%:%
%:%597=438%:%
%:%598=438%:%
%:%599=439%:%
%:%600=440%:%
%:%620=445%:%
%:%632=448%:%
%:%633=449%:%
%:%634=450%:%
%:%635=451%:%
%:%636=452%:%
%:%637=453%:%
%:%639=456%:%
%:%640=456%:%
%:%641=457%:%
%:%642=458%:%
%:%643=459%:%
%:%644=460%:%
%:%659=466%:%
%:%660=467%:%
%:%661=468%:%
%:%662=469%:%
%:%663=470%:%
%:%664=471%:%
%:%665=472%:%
%:%666=473%:%
%:%667=474%:%
%:%668=475%:%
%:%669=476%:%
%:%670=477%:%
%:%671=478%:%
%:%672=479%:%
%:%673=480%:%
%:%674=481%:%
%:%675=482%:%
%:%676=483%:%
%:%677=484%:%
%:%678=485%:%
%:%679=486%:%
%:%680=487%:%
%:%681=488%:%
%:%682=489%:%
%:%683=490%:%
%:%684=491%:%
%:%685=492%:%
%:%686=493%:%
%:%687=494%:%
%:%688=495%:%
%:%689=496%:%
%:%690=497%:%
%:%691=498%:%
%:%692=499%:%
%:%693=500%:%
%:%694=501%:%
%:%695=502%:%
%:%696=503%:%
%:%697=504%:%
%:%698=505%:%
%:%699=506%:%
%:%700=507%:%
%:%701=508%:%
%:%702=509%:%
%:%703=510%:%
%:%704=511%:%
%:%705=512%:%
%:%706=513%:%
%:%707=514%:%
%:%708=515%:%
%:%709=516%:%
%:%710=517%:%
%:%711=518%:%
%:%712=519%:%
%:%713=520%:%
%:%714=521%:%
%:%715=522%:%
%:%716=523%:%
%:%717=524%:%
%:%718=525%:%
%:%719=526%:%
%:%720=527%:%
%:%721=528%:%
%:%722=529%:%
%:%723=530%:%
%:%724=531%:%
%:%725=532%:%
%:%726=533%:%
%:%727=534%:%
%:%728=535%:%
%:%729=536%:%
%:%730=537%:%
%:%731=538%:%
%:%732=539%:%
%:%733=540%:%
%:%734=541%:%
%:%735=542%:%
%:%736=543%:%
%:%737=544%:%
%:%738=545%:%
%:%739=546%:%
%:%740=547%:%
%:%741=548%:%
%:%742=549%:%
%:%743=550%:%
%:%744=551%:%
%:%745=552%:%
%:%746=553%:%
%:%747=554%:%
%:%748=555%:%
%:%749=556%:%
%:%750=557%:%
%:%751=558%:%
%:%752=559%:%
%:%753=560%:%
%:%754=561%:%
%:%755=562%:%
%:%756=563%:%
%:%757=564%:%
%:%761=568%:%
%:%762=569%:%
%:%763=570%:%
%:%764=571%:%
%:%765=572%:%
%:%767=575%:%
%:%768=575%:%
%:%769=576%:%
%:%770=577%:%
%:%771=578%:%
%:%772=579%:%
%:%773=580%:%
%:%774=581%:%
%:%789=587%:%
%:%790=588%:%
%:%791=589%:%
%:%792=590%:%
%:%793=591%:%
%:%794=592%:%
%:%795=593%:%
%:%796=594%:%
%:%797=595%:%
%:%798=596%:%
%:%799=597%:%
%:%800=598%:%
%:%801=599%:%
%:%802=600%:%
%:%803=601%:%
%:%804=602%:%
%:%806=605%:%
%:%807=605%:%
%:%808=606%:%
%:%809=607%:%
%:%810=608%:%
%:%811=609%:%
%:%826=615%:%
%:%827=616%:%
%:%828=617%:%
%:%829=618%:%
%:%831=621%:%
%:%832=621%:%
%:%833=622%:%
%:%834=623%:%
%:%835=624%:%
%:%836=625%:%
%:%851=631%:%
%:%852=632%:%
%:%853=633%:%
%:%854=634%:%
%:%855=635%:%
%:%856=636%:%
%:%857=637%:%
%:%858=638%:%
%:%859=639%:%
%:%868=642%:%
%:%880=645%:%
%:%881=646%:%
%:%882=647%:%
%:%883=648%:%
%:%884=649%:%
%:%885=650%:%
%:%886=651%:%
%:%887=652%:%
%:%888=653%:%
%:%889=654%:%
%:%890=655%:%
%:%891=656%:%
%:%892=657%:%
%:%893=658%:%
%:%894=659%:%
%:%895=660%:%
%:%896=661%:%
%:%897=662%:%
%:%898=663%:%
%:%899=664%:%
%:%900=665%:%
%:%901=666%:%
%:%902=667%:%
%:%903=668%:%
%:%904=669%:%
%:%905=670%:%
%:%907=673%:%
%:%908=673%:%
%:%909=674%:%
%:%910=675%:%
%:%912=678%:%
%:%913=679%:%
%:%914=680%:%
%:%915=681%:%
%:%916=682%:%
%:%917=683%:%
%:%918=684%:%
%:%919=685%:%
%:%921=688%:%
%:%922=688%:%
%:%923=689%:%
%:%924=690%:%
%:%925=691%:%
%:%926=692%:%
%:%927=692%:%
%:%928=693%:%
%:%929=694%:%
%:%938=699%:%
%:%950=702%:%
%:%951=703%:%
%:%952=704%:%
%:%953=705%:%
%:%955=708%:%
%:%956=708%:%
%:%957=709%:%
%:%958=710%:%
%:%961=713%:%
%:%962=714%:%
%:%963=715%:%
%:%964=715%:%
%:%965=716%:%
%:%966=717%:%
%:%982=731%:%
%:%983=732%:%
%:%984=733%:%
%:%985=734%:%
%:%986=735%:%
%:%987=736%:%
%:%988=737%:%
%:%989=738%:%
%:%990=739%:%
%:%991=740%:%
%:%992=741%:%
%:%993=742%:%
%:%994=743%:%
%:%995=744%:%
%:%996=745%:%
%:%997=746%:%
%:%998=747%:%
%:%999=748%:%
%:%1000=749%:%
%:%1001=750%:%
%:%1002=751%:%
%:%1003=752%:%
%:%1004=753%:%
%:%1005=754%:%
%:%1006=755%:%
%:%1007=756%:%
%:%1008=757%:%
%:%1009=758%:%
%:%1010=759%:%
%:%1011=760%:%
%:%1012=761%:%
%:%1013=762%:%
%:%1014=763%:%
%:%1015=764%:%
%:%1016=765%:%
%:%1017=766%:%
%:%1018=767%:%
%:%1020=770%:%
%:%1021=770%:%
%:%1022=771%:%
%:%1049=799%:%
%:%1050=800%:%
%:%1051=801%:%
%:%1053=804%:%
%:%1054=804%:%
%:%1055=805%:%
%:%1065=810%:%
%:%1077=813%:%
%:%1078=814%:%
%:%1079=815%:%
%:%1080=816%:%
%:%1081=817%:%
%:%1082=818%:%
%:%1083=819%:%
%:%1084=820%:%
%:%1085=821%:%
%:%1086=822%:%
%:%1087=823%:%
%:%1088=824%:%
%:%1089=825%:%
%:%1090=826%:%
%:%1091=827%:%
%:%1092=828%:%
%:%1093=829%:%
%:%1094=830%:%
%:%1096=833%:%
%:%1097=833%:%
%:%1098=834%:%
%:%1099=835%:%
%:%1100=836%:%
%:%1101=837%:%
%:%1102=837%:%
%:%1103=838%:%
%:%1104=839%:%
%:%1105=840%:%
%:%1106=840%:%
%:%1107=841%:%
%:%1108=842%:%
%:%1123=848%:%
%:%1124=849%:%
%:%1125=850%:%
%:%1126=851%:%
%:%1127=852%:%
%:%1128=853%:%
%:%1129=854%:%
%:%1130=855%:%
%:%1131=856%:%
%:%1132=857%:%
%:%1133=858%:%
%:%1134=859%:%
%:%1135=860%:%
%:%1136=861%:%
%:%1137=862%:%
%:%1138=863%:%
%:%1139=864%:%
%:%1140=865%:%
%:%1141=866%:%
%:%1142=867%:%
%:%1151=870%:%
%:%1163=873%:%
%:%1164=874%:%
%:%1165=875%:%
%:%1166=876%:%
%:%1167=877%:%
%:%1168=878%:%
%:%1169=879%:%
%:%1170=880%:%
%:%1172=883%:%
%:%1173=883%:%
%:%1174=884%:%
%:%1175=885%:%
%:%1176=886%:%
%:%1177=887%:%
%:%1178=888%:%
%:%1179=889%:%
%:%1196=896%:%
%:%1197=896%:%
%:%1198=897%:%
%:%1199=898%:%
%:%1200=899%:%
%:%1201=900%:%
%:%1202=901%:%
%:%1203=902%:%
%:%1204=903%:%
%:%1221=910%:%
%:%1222=910%:%
%:%1223=911%:%
%:%1224=912%:%
%:%1225=913%:%
%:%1226=914%:%
%:%1227=915%:%
%:%1228=916%:%
%:%1245=923%:%
%:%1246=923%:%
%:%1247=924%:%
%:%1248=925%:%
%:%1249=926%:%
%:%1250=927%:%
%:%1251=928%:%
%:%1252=929%:%
%:%1253=930%:%
%:%1277=937%:%
%:%1289=940%:%
%:%1290=941%:%
%:%1291=942%:%
%:%1292=943%:%
%:%1293=944%:%
%:%1294=945%:%
%:%1295=946%:%
%:%1296=947%:%
%:%1297=948%:%
%:%1298=949%:%
%:%1299=950%:%
%:%1300=951%:%
%:%1301=952%:%
%:%1302=953%:%
%:%1303=954%:%
%:%1304=955%:%
%:%1305=956%:%
%:%1306=957%:%
%:%1307=958%:%
%:%1308=959%:%
%:%1309=960%:%
%:%1310=961%:%
%:%1311=962%:%
%:%1312=963%:%
%:%1313=964%:%
%:%1314=965%:%
%:%1315=966%:%
%:%1316=967%:%
%:%1317=968%:%
%:%1318=969%:%
%:%1319=970%:%
%:%1320=971%:%
%:%1321=972%:%
%:%1330=975%:%
%:%1342=978%:%
%:%1343=979%:%
%:%1344=980%:%
%:%1345=981%:%
%:%1346=982%:%
%:%1347=983%:%
%:%1348=984%:%
%:%1349=985%:%
%:%1350=986%:%
%:%1351=987%:%
%:%1352=988%:%
%:%1353=989%:%
%:%1354=990%:%
%:%1355=991%:%
%:%1356=992%:%
%:%1357=993%:%
%:%1358=994%:%
%:%1359=995%:%
%:%1360=996%:%
%:%1361=997%:%
%:%1362=998%:%
%:%1363=999%:%
%:%1364=1000%:%
%:%1365=1001%:%
%:%1366=1002%:%
%:%1367=1003%:%
%:%1368=1004%:%
%:%1369=1005%:%
%:%1370=1006%:%
