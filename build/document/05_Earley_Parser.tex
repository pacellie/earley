%
\begin{isabellebody}%
\setisabellecontext{{\isadigit{0}}{\isadigit{5}}{\isacharunderscore}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}Parser}%
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupchapter{Earley Parser Implementation \label{chap:05}%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
Although a recognizer is a useful tool, for most practical applications we would like to - not only -
know if the language specified by the grammar accepts the input, but we also want to obtain additional information
of how the input can be derived in the form of parse trees. In particular, for our running example, the
grammar $S ::= S + S \, | \, x$ and the input $\omega = x + x + x$, we want to obtain the two possible parse
trees illustrated in Figures \ref{fig:tree1} and \ref{fig:tree2}. But constructing all possible parse trees at once is no
trivial task.

\begin{figure}[htpb]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \psframebox[linestyle=none,framesep=10pt]{%
        \pstree{\LFTr{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
          \pstree{\LFTr{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]x}
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]x}}}
          \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
          \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]S}}}}
        \caption{Parse Tree: $\omega = (x + x) + x$} \label{fig:tree1}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \psframebox[linestyle=none,framesep=10pt]{%
        \pstree{\LFTr{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
          \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]x}
          \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
          \pstree{\LFTr{t}{\fontspec{Noto Sans}[Script=Latin]S}}{\pstree{\Tp[edge=none]}{%
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]x}
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]+}
            \LFTw{t}{\fontspec{Noto Sans}[Script=Latin]x}}}}}}
        \caption{Parse Tree: $\omega = x + (x + x)$} \label{fig:tree2}
    \end{minipage}
\end{figure}

Earley \cite{Earley:1970} turns his recognizer into a parser by adding the following
pointers. If the algorithm performs a completion and constructs an item $B \rightarrow \, \alpha A \bullet \beta, i, k$,
it adds a pointer from the \textit{instance of the non-terminal} $A$ to the complete item
$A \rightarrow \, \gamma \bullet, j, k$. If there exists more than one possible way to complete the non-terminal
$A$ and obtain the item $B \rightarrow \, \alpha A \bullet \beta, i, k$, then multiple pointers originate
from the instance of the non-terminal $A$. Annotating every non-terminal of the right-hand side of the item
$A \rightarrow \, \gamma \bullet, j, k$ recursively with pointers thus represents the derivation trees for
the non-terminal $A$. Finally, after termination of the algorithm, the non-terminal that represents the start symbol
contains pointers representing all possible derivation trees.

Note that Earley's pointers connect instances of non-terminals, but Tomita \cite{Tomita:1985} showed
that this approach is incorrect and may lead to spurious derivations in certain cases. Scott \cite{Scott:2008}
presents an example for the grammar $S ::= SS \, | \, x$ and the input $\omega = xxx$. Earley's parser
correctly constructs the parse trees for the input but additionally returns erroneous parse trees representing
derivations of $xx$ and $xxxx$. The problem lies in the fact that left- and rightmost derivations are
intertwined when they should not be, since pointers originate from instances of non-terminals and don't
connect Earley items.

The most well-known data structure for representing all possible derivations, a shared packed parse
forest (SPPF), was introduced by Tomita \cite{Tomita:1985}. But Johnson \cite{Johnson:1991} has
shown that Tomita's representation of SPPFs are of worst case unbounded polynomial size and thus
would turn our $\mathcal{O}(n^4)$ recognizer into an unbounded polynomial parser. Scott \cite{Scott:2008}
adjust the SPPF data structure slightly and presents two algorithms based on Earley's recognizer that
are of worst case cubic space and time. Unfortunately, these algorithms are highly non-trivial and
very much imperative in nature, and thus not only exceed the scope of this thesis but are also
very difficult to map to a functional approach.

In this chapter we develop an efficient functional algorithm constructing a single parse
tree in Section \ref{sec:parse-tree} and prove its correctness. In Section \ref{sec:parse-forest}
we generalize this approach, introducing a data structure representing all possible parse trees
as a parse forest, adjusting the parse tree algorithm to compute such a forest and prove termination
and soundness of the algorithm. Finally, in Section \ref{sec:word} we discuss the missing
completeness proof and the performance of the algorithm and compare our approach to the algorithm of Scott in greater detail.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsection{A Single Parse Tree \label{sec:parse-tree}%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
The data structure \isa{tree} represents parse trees as shown in Figures \ref{fig:tree1} and \ref{fig:tree2}.
A \isa{Leaf} always contains a single symbol (either terminal or non-terminal for partial derivation trees), a \isa{Branch} consists of one non-terminal
symbol and a list of subtrees. The function \isa{root{\isacharunderscore}{\kern0pt}tree} returns the symbol of the root of the
parse tree. The yield of a leaf is its single symbol; to compute the yield for a branch with
subtrees \isa{ts} we apply the function \isa{yield{\isacharunderscore}{\kern0pt}tree} recursively and concatenate the results.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{datatype}\isamarkupfalse%
\ {\isacharprime}{\kern0pt}a\ tree\ {\isacharequal}{\kern0pt}\isanewline
\ \ Leaf\ {\isacharprime}{\kern0pt}a\isanewline
{\isacharbar}{\kern0pt}\ Branch\ {\isacharprime}{\kern0pt}a\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ tree\ list{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ root{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ tree\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}root{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}Leaf\ a{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ a{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}root{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}Branch\ N\ {\isacharunderscore}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ N{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ yield{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ tree\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ sentential{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}yield{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}Leaf\ a{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}a{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}yield{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}Branch\ {\isacharunderscore}{\kern0pt}\ ts{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ concat\ {\isacharparenleft}{\kern0pt}map\ yield{\isacharunderscore}{\kern0pt}tree\ ts{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\begin{isamarkuptext}%
We introduce three notions of well-formedness for parse trees:
\begin{itemize}
  \item \isa{wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree}: A parse tree must represent a valid derivation tree according the the grammar \isa{{\isasymG}}.
    A leaf of a parse tree is always well-formed by construction. For each branch \isa{Branch\ N\ ts}
    there has to exists a production rule $N \rightarrow \, $ \isa{map\ root{\isacharunderscore}{\kern0pt}tree\ ts} corresponding to the grammar \isa{{\isasymG}} and each subtree \isa{t\ {\isasymin}\ set\ ts} has to be well-formed.
  \item \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree}: Each branch \isa{Branch\ N\ ts} corresponds to an Earley item
    $N \rightarrow \, \alpha \bullet \beta, i, j$ such that the roots of the subtrees \isa{ts} and
    \isa{{\isasymalpha}} coincide. Note that a branch is only well-formed according to the grammar if
    the roots of the subtrees form a \textit{complete} right-hand side of a production rule of the grammar.
    In contrast, a branch is well-formed according to an item if the roots of the subtrees are equal
    to \isa{{\isasymalpha}}, or, since we assume that Earley items are themselves well-formed, a \textit{prefix}
    of a right-hand side of a production rule.
  \item \isa{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree}: For an item $N \rightarrow \, \alpha \bullet \beta, i, j$ the yield
    of a parse tree has to match the substring \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}i{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}j{\isasymrangle}} of the input.
\end{itemize}%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{fun}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ cfg\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isacharunderscore}{\kern0pt}\ {\isacharparenleft}{\kern0pt}Leaf\ a{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ True{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isacharparenleft}{\kern0pt}Branch\ N\ ts{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymexists}r\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}{\isasymRR}\ {\isasymG}{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\ N\ {\isacharequal}{\kern0pt}\ rule{\isacharunderscore}{\kern0pt}head\ r\ {\isasymand}\ map\ root{\isacharunderscore}{\kern0pt}tree\ ts\ {\isacharequal}{\kern0pt}\ rule{\isacharunderscore}{\kern0pt}body\ r{\isacharparenright}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}t\ {\isasymin}\ set\ ts{\isachardot}{\kern0pt}\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ cfg\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isacharunderscore}{\kern0pt}\ {\isacharparenleft}{\kern0pt}Leaf\ a{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ True{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ {\isacharparenleft}{\kern0pt}Branch\ N\ ts{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ N\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ x\ {\isasymand}\isanewline
\ \ \ \ map\ root{\isacharunderscore}{\kern0pt}tree\ ts\ {\isacharequal}{\kern0pt}\ take\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}bullet\ x{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x{\isacharparenright}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}t\ {\isasymin}\ set\ ts{\isachardot}{\kern0pt}\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t\ {\isasymequiv}\ yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isasymrangle}{\isachardoublequoteclose}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Pointer Lemmas%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
In Chapter \ref{chap:04} we extended the algorithm of Chapter \ref{chapter:3} in two orthogonal
ways: implementing sets as lists and adding the additional information to construct parse trees
in the form null, predecessor, and predecessor/reduction pointers. But we did not formally define
the semantics of these pointers nor prove anything about their construction. In the following we
define and proof soundness of the pointers.

\begin{itemize}
  \item A null pointer \isa{Null} of an entry is sound if it \isa{predicts} the item $x$ of
    the entry, or the bullet of $x$ is at the beginning of the right-hand side of its production rule
    and we have not yet scanned any substring of the input, or item end and origin are identical.
  \item A predecessor pointer \isa{Pre\ pre} of an entry $e$ is sound for the input \isa{{\isasymomega}}, bins \isa{bs},
    and the index of the current bin $k$ if $k > 0$, the predecessor index does not exceed the length
    of the predecessor bin at index $k-1$, and the predecessor item in bin $k-1$ at index $pre$ \isa{scans}
    the item of the entry $e$. An item $x'$ \isa{scans} item $x$ for index $k$ if the next symbol of
    $x'$ coincides with the terminal symbol at index $k-1$ in the input \isa{{\isasymomega}} and the item $x$ can be obtained
    by \isa{inc{\isacharunderscore}{\kern0pt}item\ x{\isacharprime}{\kern0pt}\ k}. 
  \item Finally, we define the soundness of a pointer \isa{PreRed\ p\ ps} of an entry $e$ for each predecessor/reduction
    triple \isa{{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}p\ {\isacharhash}{\kern0pt}\ ps{\isacharparenright}{\kern0pt}}. The index $k'$ of the predecessor bin must be strictly
    smaller than $k$, and both the predecessor and the reduction index must be within the bounds of their
    respective bins, or bin $k'$ and $k$. Additionally, predicate \isa{completes} holds for $k$,
    the predecessor item $x'$, the item $x$ of entry $e$ and the reduction item $y$, capturing the semantics of
    the \isa{Complete} operation: The next symbol of $x'$ is the non-terminal $N$ which coincides
    with the item rule head of $y$. Furthermore, the item $y$ is complete and the origin index of $y$
    aligns with the end index of $x'$. Finally, item $x$ can be obtained once more by \isa{inc{\isacharunderscore}{\kern0pt}item\ x{\isacharprime}{\kern0pt}\ k}.
\end{itemize}%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ predicts\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}predicts\ x\ {\isasymequiv}\ item{\isacharunderscore}{\kern0pt}bullet\ x\ {\isacharequal}{\kern0pt}\ {\isadigit{0}}\ {\isasymand}\ item{\isacharunderscore}{\kern0pt}origin\ x\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}end\ x{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}null{\isacharunderscore}{\kern0pt}ptr\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ entry\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}null{\isacharunderscore}{\kern0pt}ptr\ e\ {\isasymequiv}\ pointer\ e\ {\isacharequal}{\kern0pt}\ Null\ {\isasymlongrightarrow}\ predicts\ {\isacharparenleft}{\kern0pt}item\ e{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ scans\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}scans\ {\isasymomega}\ k\ x{\isacharprime}{\kern0pt}\ x\ {\isasymequiv}\ x\ {\isacharequal}{\kern0pt}\ inc{\isacharunderscore}{\kern0pt}item\ x{\isacharprime}{\kern0pt}\ k\ {\isasymand}\ {\isacharparenleft}{\kern0pt}{\isasymexists}a{\isachardot}{\kern0pt}\ next{\isacharunderscore}{\kern0pt}symbol\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ a\ {\isasymand}\ {\isasymomega}{\isacharbang}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ a{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}pre{\isacharunderscore}{\kern0pt}ptr\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ entry\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}pre{\isacharunderscore}{\kern0pt}ptr\ {\isasymomega}\ bs\ k\ e\ {\isasymequiv}\ {\isasymforall}pre{\isachardot}{\kern0pt}\ pointer\ e\ {\isacharequal}{\kern0pt}\ Pre\ pre\ {\isasymlongrightarrow}\isanewline
\ \ \ \ k\ {\isachargreater}{\kern0pt}\ {\isadigit{0}}\ {\isasymand}\ pre\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbar}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ scans\ {\isasymomega}\ k\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbang}{\kern0pt}pre{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item\ e{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ completes\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ item\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}completes\ k\ x{\isacharprime}{\kern0pt}\ x\ y\ {\isasymequiv}\ x\ {\isacharequal}{\kern0pt}\ inc{\isacharunderscore}{\kern0pt}item\ x{\isacharprime}{\kern0pt}\ k\ {\isasymand}\ is{\isacharunderscore}{\kern0pt}complete\ y\ {\isasymand}\ item{\isacharunderscore}{\kern0pt}origin\ y\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}end\ x{\isacharprime}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymexists}N{\isachardot}{\kern0pt}\ next{\isacharunderscore}{\kern0pt}symbol\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ N\ {\isasymand}\ N\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ y{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}prered{\isacharunderscore}{\kern0pt}ptr\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ entry\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}prered{\isacharunderscore}{\kern0pt}ptr\ bs\ k\ e\ {\isasymequiv}\ {\isasymforall}p\ ps\ k{\isacharprime}{\kern0pt}\ pre\ red{\isachardot}{\kern0pt}\ pointer\ e\ {\isacharequal}{\kern0pt}\ PreRed\ p\ ps\ {\isasymand}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}p{\isacharhash}{\kern0pt}ps{\isacharparenright}{\kern0pt}\ {\isasymlongrightarrow}\ k{\isacharprime}{\kern0pt}\ {\isacharless}{\kern0pt}\ k\ {\isasymand}\ pre\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharbar}{\kern0pt}\ {\isasymand}\ red\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbar}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ completes\ k\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharbang}{\kern0pt}pre{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item\ e{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}red{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs\ {\isasymequiv}\ {\isasymforall}k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}{\isachardot}{\kern0pt}\ {\isasymforall}e\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\isanewline
\ \ \ \ sound{\isacharunderscore}{\kern0pt}null{\isacharunderscore}{\kern0pt}ptr\ e\ {\isasymand}\ sound{\isacharunderscore}{\kern0pt}pre{\isacharunderscore}{\kern0pt}ptr\ {\isasymomega}\ bs\ k\ e\ {\isasymand}\ sound{\isacharunderscore}{\kern0pt}prered{\isacharunderscore}{\kern0pt}ptr\ bs\ k\ e{\isachardoublequoteclose}%
\begin{isamarkuptext}%
We then prove the semantics of the pointers. The structure of the proofs is as usual: we first
proof pointer soundness for the basic operations \isa{bin{\isacharunderscore}{\kern0pt}upd}, \isa{bin{\isacharunderscore}{\kern0pt}upds}, and \isa{bins{\isacharunderscore}{\kern0pt}upd}.
Followed by the corresponding proofs for the computation of a single bin or functions \isa{Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharprime}{\kern0pt}}
and \isa{Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list}. Finally, we prove that the initial bins are sound, and functions \isa{Earley{\isacharunderscore}{\kern0pt}list}
and \isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list} maintain this property. Although it should be intuitively clear that the
semantics of pointers hold, the proofs are surprisingly not trivial at all, especially the soundness
proofs for functions \isa{bin{\isacharunderscore}{\kern0pt}upd} and \isa{Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharprime}{\kern0pt}}. The complexity mostly stems from
the predecessor/reduction case that requires a quite significant amount of case splitting due to the indexing and dependence
on the type of the pointers of the newly inserted items. Nonetheless, since the proofs do not reveal anything new in structure
but are very technical, we only state them and omit going into detail.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}upd{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}distinct\ {\isacharparenleft}{\kern0pt}items\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}null{\isacharunderscore}{\kern0pt}ptr\ e{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}pre{\isacharunderscore}{\kern0pt}ptr\ {\isasymomega}\ bs\ k\ e{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}prered{\isacharunderscore}{\kern0pt}ptr\ bs\ k\ e{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}bs{\isacharbrackleft}{\kern0pt}k\ {\isacharcolon}{\kern0pt}{\isacharequal}{\kern0pt}\ bin{\isacharunderscore}{\kern0pt}upd\ e\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}upds{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}distinct\ {\isacharparenleft}{\kern0pt}items\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}distinct\ {\isacharparenleft}{\kern0pt}items\ es{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isasymforall}e\ {\isasymin}\ set\ es{\isachardot}{\kern0pt}\ sound{\isacharunderscore}{\kern0pt}null{\isacharunderscore}{\kern0pt}ptr\ e\ {\isasymand}\ sound{\isacharunderscore}{\kern0pt}pre{\isacharunderscore}{\kern0pt}ptr\ {\isasymomega}\ bs\ k\ e\ {\isasymand}\ sound{\isacharunderscore}{\kern0pt}prered{\isacharunderscore}{\kern0pt}ptr\ bs\ k\ e{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}bs{\isacharbrackleft}{\kern0pt}k\ {\isacharcolon}{\kern0pt}{\isacharequal}{\kern0pt}\ bin{\isacharunderscore}{\kern0pt}upds\ es\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharprime}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}k{\isacharcomma}{\kern0pt}\ {\isasymG}{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ bs{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}earley{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}items\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}bins\ bs{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\ \isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharprime}{\kern0pt}\ k\ {\isasymG}\ {\isasymomega}\ bs\ i{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}k{\isacharcomma}{\kern0pt}\ {\isasymG}{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ bs{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}earley{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}items\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}bins\ bs{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list\ k\ {\isasymG}\ {\isasymomega}\ bs{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}Init{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}Init{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}k\ {\isasymle}\ {\isacharbar}{\kern0pt}{\isasymomega}{\isacharbar}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}Earley{\isacharunderscore}{\kern0pt}list\ k\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ sound{\isacharunderscore}{\kern0pt}ptrs{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{The Parse Tree Algorithm%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
After execution of the \isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list} algorithm we obtain bins representing the complete set
of Earley items. The null, predecessor, and predecessor/reduction pointers provide a way to navigate
between items or through these bins, and, since they are sound, a way to construct derivation trees.
The function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}} constructs a \textit{single} parse tree corresponding to the item $x$ of entry $e$ at index $i$ of the $k$-th bin according to the
well-formedness definitions from the beginning of this section.

If the pointer of entry $e$ is a null pointer, the algorithm starts building the tree rooted at
the left-hand side non-terminal $N$ of the production rule of the item $x$ by constructing an initially
empty branch containing the non-terminal $N$ and an empty list of subtrees. If the algorithm encounters
a predecessor pointer \isa{Pre\ pre}, it first recursively calls itself, for bin $B_{k-1}$ and the
predecessor index \isa{pre}, obtaining a partial parse tree \isa{Branch\ N\ ts}. Since the predecessor pointer is sound,
in particular the \isa{scans} predicate holds, we append a Leaf containing the terminal symbol at index
$k-1$ of the input \isa{{\isasymomega}} to the list of substrees \isa{ts}. In the case that
the pointer contains predecessor/reduction triples the algorithm only considers the first triple
\isa{{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}} due to the fact that we are only constructing a single derivation tree. As for the predecessor
case, it recursively calls itself obtaining a partial derivation tree \isa{Branch\ N\ ts} for the predecessor index \isa{pre}
and bin $k'$, followed by yet another recursive call for the reduction item at the reduction index \isa{red}
in the current bin $k$, constructing a complete derivation tree $t$. This time the \isa{completes}
predicate holds, thus the next symbol of the predecessor item coincides with the item rule head of
the reduction item, or we are allowed to append the complete tree $t$ to the list of substrees \isa{ts}.

Some minor implementation details to note are: the function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}} is a partial function,
and not tail recursive, hence it has to return an optional value, as explained in Section \ref{sec:04-wellformedness}.
Furthermore, we are using the monadic do-notation commonly found in functional programming languages for the option
monad. An alternative but equivalent implementation would use explicit case distinctions. Finally, if
the function computes some value it is always a branch, never a single leaf.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{partial{\isacharunderscore}{\kern0pt}function}\isamarkupfalse%
\ {\isacharparenleft}{\kern0pt}option{\isacharparenright}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ option{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ let\ e\ {\isacharequal}{\kern0pt}\ bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i\ in\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ case\ pointer\ e\ of\isanewline
\ \ \ \ \ \ Null\ {\isasymRightarrow}\ Some\ {\isacharparenleft}{\kern0pt}Branch\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ {\isacharparenleft}{\kern0pt}item\ e{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ {\isacharbar}{\kern0pt}\ Pre\ pre\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ do\ {\isacharbraceleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ t\ {\isasymleftarrow}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}\ pre{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ case\ t\ of\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ Branch\ N\ ts\ {\isasymRightarrow}\ Some\ {\isacharparenleft}{\kern0pt}Branch\ N\ {\isacharparenleft}{\kern0pt}ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}Leaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}{\isacharbang}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ {\isacharbar}{\kern0pt}\ {\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ None\ {\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ {\isacharbar}{\kern0pt}\ PreRed\ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ {\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ do\ {\isacharbraceleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ t\ {\isasymleftarrow}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k{\isacharprime}{\kern0pt}\ pre{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ case\ t\ of\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ Branch\ N\ ts\ {\isasymRightarrow}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ do\ {\isacharbraceleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ t\ {\isasymleftarrow}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ red{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Some\ {\isacharparenleft}{\kern0pt}Branch\ N\ {\isacharparenleft}{\kern0pt}ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}t{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isacharbraceright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ {\isacharbar}{\kern0pt}\ {\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ None\ {\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\begin{isamarkuptext}%
The function \isa{build{\isacharunderscore}{\kern0pt}tree} computes a complete derivation tree if there exists one. It searches the last bin for any finished items or items of the form
$S \rightarrow \gamma \bullet, 0, n$ where $S$ is the start symbol of the grammar \isa{{\isasymG}} and $n$ denotes
the length of the input \isa{{\isasymomega}}. If there exists such an item, it calls function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}}
obtaining some parse tree representing the derivation \isa{{\isasymG}\ {\isasymturnstile}\ S\ \ensuremath{\Rightarrow^{\ast}}\ {\isasymomega}} (we will have to proof that it never returns \isa{None}),
otherwise it returns \isa{None} since there cannot exist a valid parse tree due to the correctness
proof for the Earley bins of Chapter \ref{chapter:3} if the argument \isa{bs} was constructed by the
\isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list} function.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}tree\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ cfg\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ option{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isasymomega}\ bs\ {\isasymequiv}\isanewline
\ \ \ \ let\ k\ {\isacharequal}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}\ in\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ case\ filter{\isacharunderscore}{\kern0pt}with{\isacharunderscore}{\kern0pt}index\ {\isacharparenleft}{\kern0pt}{\isasymlambda}x{\isachardot}{\kern0pt}\ is{\isacharunderscore}{\kern0pt}finished\ {\isasymG}\ {\isasymomega}\ x{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}items\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ of\isanewline
\ \ \ \ \ \ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}\ {\isasymRightarrow}\ None\isanewline
\ \ \ \ {\isacharbar}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isacharunderscore}{\kern0pt}{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}{\isacharhash}{\kern0pt}{\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Termination%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
The function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}} uses the null, predecessor and predecessor/reduction pointers to
navigate through the given bins by calling itself recursively. Sound pointers ensure that we are not
indexing outside of the bins, but this does not imply that the algorithm terminates. In the following
we outline the cases for which it always terminates with some parse tree. Let's assume the
function starts its computation at index $i$ of the $k$-th bin. If it encounters a null pointer, it
terminates immediately. If the pointer is a simple predecessor pointer, it calls itself recursively
for the previous bin. Due to the soundness of the predecessor pointer the index $k-1$ of this bin
is strictly smaller than $k$. A similar argument holds for the first recursive call if the pointer
is a predecessor/reduction pointer for the predecessor case (\isa{k{\isacharprime}{\kern0pt}\ {\isacharless}{\kern0pt}\ k}). Or, we are following
the pointers \textit{strictly} back to the origin bin $B_0$ and thus must terminate at some point. But for
the reduction pointer we run into a problem: the recursive call for the item at index $i$ is in the same
bin $k$ but for the reduction index $red$, which in turn might contain again reduction triples and so on.
Hence, it is possible that we end up in a cycle of reductions and never terminate. Take for example the
grammer $A ::= x \, | \, B \quad B ::= A$ and the input $\omega = x$. Table \ref{tab:cyclic-pointers}
illustrates the bins computed by the algorithm of Chapter \ref{chapter:3}. Bin $B_1$ contains the entry
$B \rightarrow \, A \bullet, 0, 1; (0, 2, 0),(0, 2, 2)$ at index $1$ and its second reduction triple
$(0, 2, 2)$ a reduction pointer to index $2$ of the same bin. There we find the entry
$A \rightarrow \, B \bullet, 0, 1; (0, 0, 1)$ with a reduction pointer to index $1$ completing the
cycle. This is indeed valid since the grammar itself is cyclic, allowing for derivations of the form
$A \rightarrow \, B \rightarrow \, A \rightarrow \dots \rightarrow \, A \rightarrow \, x$.

  \begin{table}[htpb]
    \caption[Cyclic reduction pointers]{Cyclic reduction pointers} \label{tab:cyclic-pointers}
    \centering
    \begin{tabular}{| l | l | l |}
          & $B_0$                                     & $B_1$ \\
      \midrule
        0 & $A \rightarrow \, \bullet B, 0, 0; \bot$  & $A \rightarrow \, x \bullet, 0, 1; 1$ \\
        1 & $A \rightarrow \, \bullet x, 0, 0; \bot$  & $B \rightarrow \, A \bullet, 0, 1; (0, 2, 0),(0, 2, 2)$ \\
        2 & $B \rightarrow \, \bullet A, 0, 0; \bot$  & $A \rightarrow \, B \bullet, 0, 1; (0, 0, 1)$ \\
    \end{tabular}
  \end{table}

We need to address this problem when constructing all possible parse trees in Section \ref{sec:parse-forest},
but for now we are lucky. While constructing a single parse tree the algorithm always follows the
first reduction triple that is created when the entry is constructed initially. Since we only
append new entries to bins, the complete reduction item necessarily appears before the new entry with
the reduction triple. Furthermore, the implementation of the function \isa{bin{\isacharunderscore}{\kern0pt}upd} also makes sure to not change this
first triple. Thus, we know for any item at index $i$ in the $k$-th bin that its first reduction pointer $red$,
that we follow while constructing a single parse tree, is strictly smaller than $i$.

To summarize:
if the algorithm encounters a null pointer it terminates immediately, for predecessor pointers it
calls itself recursively in a bin with a strictly smaller index, and for reduction pointers it calls
itself in the same bin but for a strictly smaller index. The proofs for the monotonicity of the first
reduction pointer for functions \isa{bin{\isacharunderscore}{\kern0pt}upd}, \isa{bin{\isacharunderscore}{\kern0pt}upds}, \isa{bins{\isacharunderscore}{\kern0pt}upd}, \isa{Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list{\isacharprime}{\kern0pt}},
\isa{Earley{\isacharunderscore}{\kern0pt}bin{\isacharunderscore}{\kern0pt}list}, \isa{Earley{\isacharunderscore}{\kern0pt}list}, and \isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list} are completely analogous to
the soundness proof of the pointers. We omit them.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ mono{\isacharunderscore}{\kern0pt}red{\isacharunderscore}{\kern0pt}ptrs\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ bool{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}mono{\isacharunderscore}{\kern0pt}red{\isacharunderscore}{\kern0pt}ptrs\ bs\ {\isasymequiv}\ {\isasymforall}k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}{\isachardot}{\kern0pt}\ {\isasymforall}i\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbar}{\kern0pt}{\isachardot}{\kern0pt}\isanewline
\ \ \ \ {\isasymforall}k{\isacharprime}{\kern0pt}\ pre\ red\ ps{\isachardot}{\kern0pt}\ pointer\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ PreRed\ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ ps\ {\isasymlongrightarrow}\ red\ {\isacharless}{\kern0pt}\ i{\isachardoublequoteclose}%
\begin{isamarkuptext}%
Similarly to Chapter \ref{chapter:3} we define a suitable measure and a notion of well-formedness
for the input of the function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}} and proof an induction schema, in
the following referred to as \textit{tree induction}, by complete induction on the measure.
For the input quadruple \isa{{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}} the measure corresponds to the number of entries
in the first $k-1$ bins plus $i$. We call the input well-formed if it satisfies the following
conditions: sound and monotonic pointers, the bin index $k$ does not exceed the length of the bins, and the item
index $i$ is within the bounds of the $k$-th bin.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{fun}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}measure\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ bins\ {\isasymtimes}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ nat{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}measure\ {\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ foldl\ {\isacharparenleft}{\kern0pt}{\isacharplus}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isadigit{0}}\ {\isacharparenleft}{\kern0pt}map\ length\ {\isacharparenleft}{\kern0pt}take\ k\ bs{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharplus}{\kern0pt}\ i{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}input\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ bins\ {\isasymtimes}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat{\isacharparenright}{\kern0pt}\ set{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}input\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}\ {\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}\ {\isacharbar}{\kern0pt}\ bs\ {\isasymomega}\ k\ i{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs\ {\isasymand}\ mono{\isacharunderscore}{\kern0pt}red{\isacharunderscore}{\kern0pt}ptrs\ bs\ {\isasymand}\ k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isasymand}\ i\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbar}{\kern0pt}\ {\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}%
\begin{isamarkuptext}%
To conclude this subsection, we prove termination of the function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}}, or for
well-formed input it always terminates with some branch, by \textit{tree induction}.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}termination{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymexists}N\ ts{\isachardot}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ {\isacharequal}{\kern0pt}\ Some\ {\isacharparenleft}{\kern0pt}Branch\ N\ ts{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Correctness%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
From the previous lemma, We know that for well-formed input a call of the form \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i} always terminates
and yields some parse tree $t$. The following lemma proves that, for well-formed bins \isa{bs},
$t$ represents a parse tree according to the semantics of the Earley item $N \rightarrow \, \alpha \bullet \beta, j, k$
at index $i$ in the $k$-th bin. The parse tree is rooted at the item rule head $N$, each of its subtrees is a complete derivation
tree following the rules of the grammar, and the list of roots of the subtrees themselves coincide with
\isa{{\isasymalpha}}. Moreover, the yield of $t$ matches the subsequence from $j$ to $k$ of the input \isa{{\isasymomega}}.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{lemma}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}bins\ {\isasymG}\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ {\isacharequal}{\kern0pt}\ Some\ t{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ t\ {\isasymand}\ wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ t{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
\begin{proof}

The proof is by \textit{tree induction} and we split it into three cases according to the kind
of pointer the algorithm encounters. Let $e$ denote the entry at index $i$ in bin $k$, and $x$
be the item of $e$, or $x = N \rightarrow \, \alpha \bullet \beta, j, k$.

\begin{itemize}

  \item \isa{pointer\ e\ {\isacharequal}{\kern0pt}\ Null}: 
    We have \isa{t\ {\isacharequal}{\kern0pt}\ Branch\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ x{\isacharparenright}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}}. The root of $t$ coincides
    with the item rule head of $x$ by construction. Since the list of subtrees is empty, each of
    the subtrees is trivially well-formed according to the grammar. Moreover, we know \isa{predicts\ x},
    due to the null pointer, or the bullet of $x$ is at position $0$. Thus, we have \isa{{\isasymalpha}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}} and
    the list of subtrees \isa{{\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}} matches. In summary, we have \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t}.
    From \isa{predicts\ x}, we also know that \isa{j\ {\isacharequal}{\kern0pt}\ k}, or \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}j{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}k{\isasymrangle}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}} by definition
    of the \isa{slice} function. Since the yield of $t$ is empty, we have \isa{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t}
    and conclude the proof for the null pointer.

  \item \isa{pointer\ e\ {\isacharequal}{\kern0pt}\ Pre\ pre}:
    Let $x'$ denote the predecessor \isa{item\ {\isacharparenleft}{\kern0pt}bs\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}\ {\isacharbang}{\kern0pt}\ pre{\isacharparenright}{\kern0pt}} of the recursive function call for
    bin $k-1$ and index \isa{pre}. The function always terminates with some branch for well-formed input.
    Hence, there exists a tree \isa{Branch\ N\ ts} corresponding to the predecessor item $x'$, and we have:
    $$\isa{t\ {\isacharequal}{\kern0pt}\ Branch\ N\ {\isacharparenleft}{\kern0pt}ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}Leaf\ {\isacharparenleft}{\kern0pt}inp\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}}$$

    We also have \isa{{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharcomma}{\kern0pt}\ pre{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}input} by assumption since the predecessor pointer
    is sound and the the algorithm does not change the bins. Thus we can use the induction hypothesis and obtain:
    
    \begin{equation*}
      \begin{alignedat}{2}
        & \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x{\isacharprime}{\kern0pt}\ {\isacharparenleft}{\kern0pt}Branch\ N\ ts{\isacharparenright}{\kern0pt}} \qquad & (\isa{IH{\isadigit{1}}}) \\
        & \isa{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x{\isacharprime}{\kern0pt}\ {\isacharparenleft}{\kern0pt}Branch\ N\ ts{\isacharparenright}{\kern0pt}} \qquad & (\isa{IH{\isadigit{2}}}) 
      \end{alignedat}
    \end{equation*}

    Since the pointer is a simple predecessor pointer, the predicate \isa{scans\ {\isasymomega}\ k\ x{\isacharprime}{\kern0pt}\ x} holds and we also know that $x$ as well
    as $x'$ are well-formed bin items. Consequently, we obtain the following facts:

    \begin{equation*}
      \begin{alignedat}{2}
        & \isa{item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ x} \qquad & (a) \\
        & \isa{item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x} \qquad & (b) \\
        & \isa{item{\isacharunderscore}{\kern0pt}bullet\ x{\isacharprime}{\kern0pt}\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}bullet\ x} \qquad & (c) \\
        & \isa{next{\isacharunderscore}{\kern0pt}symbol\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ {\isacharparenleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}} \qquad & (d) \\
        & \isa{item{\isacharunderscore}{\kern0pt}origin\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ item{\isacharunderscore}{\kern0pt}origin\ x} \qquad & (e) \\
        & \isa{item{\isacharunderscore}{\kern0pt}end\ x\ {\isacharequal}{\kern0pt}\ k} \qquad & (f) \\
        & \isa{item{\isacharunderscore}{\kern0pt}end\ x{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}} \qquad & (g)
      \end{alignedat}
    \end{equation*}

    We first proof \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t}:

    \begin{equation*}
      \begin{alignedat}{2}
        & \isa{map\ root{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}Leaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}} & \\
        & \qquad = \isa{map\ root{\isacharunderscore}{\kern0pt}tree\ ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} \qquad & (1) \\
        & \qquad = \isa{take\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}bullet\ x{\isacharprime}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x{\isacharprime}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} \qquad & (2) \\
        & \qquad = \isa{take\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}bullet\ x{\isacharprime}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x{\isacharparenright}{\kern0pt}\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} \qquad & (3) \\
        & \qquad = \isa{take\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}bullet\ x{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}body\ x{\isacharparenright}{\kern0pt}} \qquad & (4)
      \end{alignedat}
    \end{equation*}

    (1) by definition.
    (2) by (\isa{IH{\isadigit{1}}}).
    (3) by (b).
    (4) by (b,c,d).
    The statement \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t} follows by (a), using once more (\isa{IH{\isadigit{1}}}) to
    prove that all subtrees are complete according to the grammar by definition of \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree}.

    To conclude the proof for the simple predecessor pointer, we prove the statement \isa{\mbox{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t}}:

    \begin{equation*}
      \begin{alignedat}{2}
        & \isa{yield{\isacharunderscore}{\kern0pt}tree\ {\isacharparenleft}{\kern0pt}Branch\ N\ {\isacharparenleft}{\kern0pt}ts\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}Leaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}} & \\
        & \qquad = \isa{concat\ {\isacharparenleft}{\kern0pt}map\ yield{\isacharunderscore}{\kern0pt}tree\ ts{\isacharparenright}{\kern0pt}\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} \qquad & (1) \\
        & \qquad = \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isacharprime}{\kern0pt}{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isacharprime}{\kern0pt}{\isasymrangle}\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}} \qquad & (2) \\
        & \qquad = \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isacharprime}{\kern0pt}{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isacharprime}{\kern0pt}\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isasymrangle}} \qquad & (3) \\
        & \qquad = \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isacharprime}{\kern0pt}\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isasymrangle}}  \qquad & (4) \\
        & \qquad = \isa{{\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isasymrangle}} \qquad & (5)
      \end{alignedat}
    \end{equation*}

    (1) by definition.
    (2) by (\isa{IH{\isadigit{2}}}). 
    (3) by (g) and the definition of \isa{slice}.
    (4) by (e).
    (5) by (f,g).

  \item \isa{pointer\ e\ {\isacharequal}{\kern0pt}\ PreRed\ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ ps}:
    The proof is similar in structure to the proof of the simple predecessor case. We only highlight
    the main differences. In contrast to only one recursive call for the predecessor item $x'$, we
    have another recursive call for the complete reduction item $y$. But we have also have an additional
    induction hypothesis. The proofs of \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t} and \isa{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t}
    are analogous to the case above replacing \isa{Leaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}\ {\isacharbang}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}} with the branch obtained from
    the second recursive call. Statements similar to (a-g) hold since all items are well-formed and
    the predicate \isa{completes\ k\ x{\isacharprime}{\kern0pt}\ x\ y} is true.

\end{itemize}

\end{proof}%
\end{isamarkuptext}\isamarkuptrue%
%
\begin{isamarkuptext}%
Next we prove that, if the function \isa{build{\isacharunderscore}{\kern0pt}tree} returns a parse tree, it is a complete and
well-formed tree according to the grammar, the root of the tree is the start symbol of the grammar,
and the yield of the tree corresponds to the input. The subsequent corollary then proves that the theorem
in particular holds if we generate the bins using the algorithm of Chapter \ref{chap:04} if we adjust
the assumptions accordingly.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}root{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}tree{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}bins\ {\isasymG}\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}mono{\isacharunderscore}{\kern0pt}red{\isacharunderscore}{\kern0pt}ptrs\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbar}{\kern0pt}{\isasymomega}{\isacharbar}{\kern0pt}\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isasymomega}\ bs\ {\isacharequal}{\kern0pt}\ Some\ t{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t\ {\isasymand}\ root{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymSS}\ {\isasymG}\ {\isasymand}\ yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
\begin{proof}

The function \isa{build{\isacharunderscore}{\kern0pt}tree} searches the last bin for any finished items. Since it returns
a tree by assumption it is successful, or finds a finished item $x$ at index $i$, and calls
the function \isa{build{\isacharunderscore}{\kern0pt}tree{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}\ i}. By assumption the input and the bins are
well-formed, we can discharge the assumptions of the previous two lemmas, obtain a tree \isa{t\ {\isacharequal}{\kern0pt}\ Branch\ N\ ts} and have:

$$\isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t\ {\isasymand}\ wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t}$$

The item $x$ is finished or its rule head is the start symbol of the grammar, it is complete, and
its origin and end respectively are $0$ and \isa{{\isacharbar}{\kern0pt}{\isasymomega}{\isacharbar}{\kern0pt}}. Due to the completeness and well-formedness
of the item \isa{wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ x\ t} implies \isa{wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t} and \isa{root{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymSS}\ {\isasymG}}.
From \isa{wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ x\ t} we have \isa{yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isacharbrackleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}origin\ x{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}item{\isacharunderscore}{\kern0pt}end\ x{\isasymrangle}} by definition,
and consequently \isa{yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}}.

\end{proof}%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{corollary}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}root{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ t{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t\ {\isasymand}\ root{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymSS}\ {\isasymG}\ {\isasymand}\ yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
We conclude this section with the final theorem stating that the function \isa{build{\isacharunderscore}{\kern0pt}tree}
returns some parse tree if and only if there exists a derivation of the input from the start symbol
of the grammar, provided we generated the bins with the algorithm of Chapter \ref{chap:04} and grammar
and input are well-formed.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ correctness{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}tree{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}is{\isacharunderscore}{\kern0pt}sentence\ {\isasymG}\ {\isasymomega}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isasymexists}t{\isachardot}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ t{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\ {\isasymG}\ {\isasymturnstile}\ {\isacharbrackleft}{\kern0pt}{\isasymSS}\ {\isasymG}{\isacharbrackright}{\kern0pt}\ {\isasymRightarrow}\isactrlsup {\isacharasterisk}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
\begin{proof}

The function \isa{build{\isacharunderscore}{\kern0pt}tree} searches the last bin for a finished item $x$.
It finds such an item and returns a parse tree if and only if the bins generated
by \isa{{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}} are \isa{recognizing} which in turn holds if and only if
there exists a derivation of the input from the start symbol of the grammar by
lemma \isa{correctness{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list} using our assumptions.

\end{proof}%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsection{A Parse Forest \label{sec:parse-forest}%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
TODO%
\end{isamarkuptext}\isamarkuptrue%
%
\begin{isamarkuptext}%
why not simply generate all parse trees integrated top down? yes for single parse tree, no for
all since exponential blow up. One option for more sharing is: different reduction item same predecessor.
We sketch a simple unoptimized algorithm:

The idea was: generalize the functional algorithm which generates a single tree to all trees
by introducing as much structural sharing as possible.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{datatype}\isamarkupfalse%
\ {\isacharprime}{\kern0pt}a\ forest\ {\isacharequal}{\kern0pt}\isanewline
\ \ FLeaf\ {\isacharprime}{\kern0pt}a\isanewline
{\isacharbar}{\kern0pt}\ FBranch\ {\isacharprime}{\kern0pt}a\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ forest\ list\ list{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ combinations\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ list\ list\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ list\ list{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}combinations\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}combinations\ {\isacharparenleft}{\kern0pt}xs{\isacharhash}{\kern0pt}xss{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}\ x{\isacharhash}{\kern0pt}cs\ {\isachardot}{\kern0pt}\ x\ {\isacharless}{\kern0pt}{\isacharminus}{\kern0pt}\ xs{\isacharcomma}{\kern0pt}\ cs\ {\isacharless}{\kern0pt}{\isacharminus}{\kern0pt}\ combinations\ xss\ {\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ trees\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ forest\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ tree\ list{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}trees\ {\isacharparenleft}{\kern0pt}FLeaf\ a{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}Leaf\ a{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}trees\ {\isacharparenleft}{\kern0pt}FBranch\ N\ fss{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ let\ tss\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}fs{\isachardot}{\kern0pt}\ concat\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}f{\isachardot}{\kern0pt}\ trees\ f{\isacharparenright}{\kern0pt}\ fs{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ fss{\isacharparenright}{\kern0pt}\ in\isanewline
\ \ \ \ map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}ts{\isachardot}{\kern0pt}\ Branch\ N\ ts{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}combinations\ tss{\isacharparenright}{\kern0pt}\isanewline
\ \ {\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{The Parse Forest Algorithm%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
\isacommand{fun}\isamarkupfalse%
\ insert{\isacharunderscore}{\kern0pt}group\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}k{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}v{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}k\ {\isasymtimes}\ {\isacharprime}{\kern0pt}v\ list{\isacharparenright}{\kern0pt}\ list\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}k\ {\isasymtimes}\ {\isacharprime}{\kern0pt}v\ list{\isacharparenright}{\kern0pt}\ list{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}insert{\isacharunderscore}{\kern0pt}group\ K\ V\ a\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharparenleft}{\kern0pt}K\ a{\isacharcomma}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}V\ a{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}insert{\isacharunderscore}{\kern0pt}group\ K\ V\ a\ {\isacharparenleft}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharcomma}{\kern0pt}\ vs{\isacharparenright}{\kern0pt}{\isacharhash}{\kern0pt}xs{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ if\ K\ a\ {\isacharequal}{\kern0pt}\ k\ then\ {\isacharparenleft}{\kern0pt}k{\isacharcomma}{\kern0pt}\ V\ a\ {\isacharhash}{\kern0pt}\ vs{\isacharparenright}{\kern0pt}\ {\isacharhash}{\kern0pt}\ xs\isanewline
\ \ \ \ else\ {\isacharparenleft}{\kern0pt}k{\isacharcomma}{\kern0pt}\ vs{\isacharparenright}{\kern0pt}\ {\isacharhash}{\kern0pt}\ insert{\isacharunderscore}{\kern0pt}group\ K\ V\ a\ xs\ \ \isanewline
\ \ {\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{fun}\isamarkupfalse%
\ group{\isacharunderscore}{\kern0pt}by\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}k{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}v{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ list\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}k\ {\isasymtimes}\ {\isacharprime}{\kern0pt}v\ list{\isacharparenright}{\kern0pt}\ list{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}group{\isacharunderscore}{\kern0pt}by\ K\ V\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isachardoublequoteclose}\isanewline
{\isacharbar}{\kern0pt}\ {\isachardoublequoteopen}group{\isacharunderscore}{\kern0pt}by\ K\ V\ {\isacharparenleft}{\kern0pt}x{\isacharhash}{\kern0pt}xs{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ insert{\isacharunderscore}{\kern0pt}group\ K\ V\ x\ {\isacharparenleft}{\kern0pt}group{\isacharunderscore}{\kern0pt}by\ K\ V\ xs{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
\isanewline
%
\endisadelimproof
\isacommand{partial{\isacharunderscore}{\kern0pt}function}\isamarkupfalse%
\ {\isacharparenleft}{\kern0pt}option{\isacharparenright}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}trees{\isacharprime}{\kern0pt}\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ nat\ {\isasymRightarrow}\ nat\ set\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ forest\ list\ option{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}trees{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ I\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ let\ e\ {\isacharequal}{\kern0pt}\ bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i\ in\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ case\ pointer\ e\ of\isanewline
\ \ \ \ \ \ Null\ {\isasymRightarrow}\ Some\ {\isacharparenleft}{\kern0pt}{\isacharbrackleft}{\kern0pt}FBranch\ {\isacharparenleft}{\kern0pt}item{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}head\ {\isacharparenleft}{\kern0pt}item\ e{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ {\isacharbar}{\kern0pt}\ Pre\ pre\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ do\ {\isacharbraceleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ pres\ {\isasymleftarrow}\ build{\isacharunderscore}{\kern0pt}trees{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}\ pre\ {\isacharbraceleft}{\kern0pt}pre{\isacharbraceright}{\kern0pt}{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ those\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}f{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ case\ f\ of\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ FBranch\ N\ fss\ {\isasymRightarrow}\ Some\ {\isacharparenleft}{\kern0pt}FBranch\ N\ {\isacharparenleft}{\kern0pt}fss\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}{\isacharbrackleft}{\kern0pt}FLeaf\ {\isacharparenleft}{\kern0pt}{\isasymomega}{\isacharbang}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ {\isacharbar}{\kern0pt}\ {\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ None\isanewline
\ \ \ \ \ \ \ \ \ \ {\isacharparenright}{\kern0pt}\ pres{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ {\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ {\isacharbar}{\kern0pt}\ PreRed\ p\ ps\ {\isasymRightarrow}\ {\isacharparenleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ let\ ps{\isacharprime}{\kern0pt}\ {\isacharequal}{\kern0pt}\ filter\ {\isacharparenleft}{\kern0pt}{\isasymlambda}{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\ red\ {\isasymnotin}\ I{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}p{\isacharhash}{\kern0pt}ps{\isacharparenright}{\kern0pt}\ in\isanewline
\ \ \ \ \ \ \ \ let\ gs\ {\isacharequal}{\kern0pt}\ group{\isacharunderscore}{\kern0pt}by\ {\isacharparenleft}{\kern0pt}{\isasymlambda}{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\ {\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isasymlambda}{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharcomma}{\kern0pt}\ red{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\ red{\isacharparenright}{\kern0pt}\ ps{\isacharprime}{\kern0pt}\ in\isanewline
\ \ \ \ \ \ \ \ map{\isacharunderscore}{\kern0pt}option\ concat\ {\isacharparenleft}{\kern0pt}those\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}{\isacharparenleft}{\kern0pt}{\isacharparenleft}{\kern0pt}k{\isacharprime}{\kern0pt}{\isacharcomma}{\kern0pt}\ pre{\isacharparenright}{\kern0pt}{\isacharcomma}{\kern0pt}\ reds{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ do\ {\isacharbraceleft}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ pres\ {\isasymleftarrow}\ build{\isacharunderscore}{\kern0pt}trees{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k{\isacharprime}{\kern0pt}\ pre\ {\isacharbraceleft}{\kern0pt}pre{\isacharbraceright}{\kern0pt}{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ rss\ {\isasymleftarrow}\ those\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}red{\isachardot}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}trees{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ red\ {\isacharparenleft}{\kern0pt}I\ {\isasymunion}\ {\isacharbraceleft}{\kern0pt}red{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ reds{\isacharparenright}{\kern0pt}{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ those\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}f{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ case\ f\ of\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ FBranch\ N\ fss\ {\isasymRightarrow}\ Some\ {\isacharparenleft}{\kern0pt}FBranch\ N\ {\isacharparenleft}{\kern0pt}fss\ {\isacharat}{\kern0pt}\ {\isacharbrackleft}{\kern0pt}concat\ rss{\isacharbrackright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isacharbar}{\kern0pt}\ {\isacharunderscore}{\kern0pt}\ {\isasymRightarrow}\ None\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ {\isacharparenright}{\kern0pt}\ pres{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ \ \ {\isacharbraceright}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ {\isacharparenright}{\kern0pt}\ gs{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \ \ {\isacharparenright}{\kern0pt}\isanewline
\ \ {\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}trees\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ cfg\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ bins\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ forest\ list\ option{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}trees\ {\isasymG}\ {\isasymomega}\ bs\ {\isasymequiv}\isanewline
\ \ \ \ let\ k\ {\isacharequal}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}\ in\isanewline
\ \ \ \ let\ finished\ {\isacharequal}{\kern0pt}\ filter{\isacharunderscore}{\kern0pt}with{\isacharunderscore}{\kern0pt}index\ {\isacharparenleft}{\kern0pt}{\isasymlambda}x{\isachardot}{\kern0pt}\ is{\isacharunderscore}{\kern0pt}finished\ {\isasymG}\ {\isasymomega}\ x{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}items\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ in\isanewline
\ \ \ \ map{\isacharunderscore}{\kern0pt}option\ concat\ {\isacharparenleft}{\kern0pt}those\ {\isacharparenleft}{\kern0pt}map\ {\isacharparenleft}{\kern0pt}{\isasymlambda}{\isacharparenleft}{\kern0pt}{\isacharunderscore}{\kern0pt}{\isacharcomma}{\kern0pt}\ i{\isacharparenright}{\kern0pt}{\isachardot}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}trees{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ {\isacharbraceleft}{\kern0pt}i{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}\ finished{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Termination%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
\isacommand{fun}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}forest{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}measure\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ bins\ {\isasymtimes}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat\ set{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ nat{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}forest{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}measure\ {\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharcomma}{\kern0pt}\ I{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ foldl\ {\isacharparenleft}{\kern0pt}{\isacharplus}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isadigit{0}}\ {\isacharparenleft}{\kern0pt}map\ length\ {\isacharparenleft}{\kern0pt}take\ {\isacharparenleft}{\kern0pt}k{\isacharplus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}\ bs{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharminus}{\kern0pt}\ card\ I{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}trees{\isacharunderscore}{\kern0pt}input\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ bins\ {\isasymtimes}\ {\isacharprime}{\kern0pt}a\ sentential\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat\ {\isasymtimes}\ nat\ set{\isacharparenright}{\kern0pt}\ set{\isachardoublequoteclose}\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}trees{\isacharunderscore}{\kern0pt}input\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}\ {\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharcomma}{\kern0pt}\ I{\isacharparenright}{\kern0pt}\ {\isacharbar}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ I{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs\ {\isasymand}\ k\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isasymand}\ i\ {\isacharless}{\kern0pt}\ {\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbar}{\kern0pt}\ {\isasymand}\ I\ {\isasymsubseteq}\ {\isacharbraceleft}{\kern0pt}{\isadigit{0}}{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}{\isacharless}{\kern0pt}{\isacharbar}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbar}{\kern0pt}{\isacharbraceright}{\kern0pt}\ {\isasymand}\ i\ {\isasymin}\ I\ {\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isanewline
\isacommand{lemma}\isamarkupfalse%
\ build{\isacharunderscore}{\kern0pt}trees{\isacharprime}{\kern0pt}{\isacharunderscore}{\kern0pt}termination{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharcomma}{\kern0pt}\ I{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}trees{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymexists}fs{\isachardot}{\kern0pt}\ build{\isacharunderscore}{\kern0pt}trees{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ I\ {\isacharequal}{\kern0pt}\ Some\ fs\ {\isasymand}\ {\isacharparenleft}{\kern0pt}{\isasymforall}f\ {\isasymin}\ set\ fs{\isachardot}{\kern0pt}\ {\isasymexists}N\ fss{\isachardot}{\kern0pt}\ f\ {\isacharequal}{\kern0pt}\ FBranch\ N\ fss{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsection{Soundness%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
\isacommand{lemma}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}trees{\isacharprime}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}bs{\isacharcomma}{\kern0pt}\ {\isasymomega}{\isacharcomma}{\kern0pt}\ k{\isacharcomma}{\kern0pt}\ i{\isacharcomma}{\kern0pt}\ I{\isacharparenright}{\kern0pt}\ {\isasymin}\ wf{\isacharunderscore}{\kern0pt}trees{\isacharunderscore}{\kern0pt}input{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}bins\ {\isasymG}\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}trees{\isacharprime}{\kern0pt}\ bs\ {\isasymomega}\ k\ i\ I\ {\isacharequal}{\kern0pt}\ Some\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}f\ {\isasymin}\ set\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}t\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}trees\ f{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}item{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ t\ {\isasymand}\ wf{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}tree\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}item\ {\isacharparenleft}{\kern0pt}bs{\isacharbang}{\kern0pt}k{\isacharbang}{\kern0pt}i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ t{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}root{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}trees{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}bins\ {\isasymG}\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}sound{\isacharunderscore}{\kern0pt}ptrs\ {\isasymomega}\ bs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isacharbar}{\kern0pt}bs{\isacharbar}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbar}{\kern0pt}{\isasymomega}{\isacharbar}{\kern0pt}\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}trees\ {\isasymG}\ {\isasymomega}\ bs\ {\isacharequal}{\kern0pt}\ Some\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}f\ {\isasymin}\ set\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}t\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}trees\ f{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t\ {\isasymand}\ root{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymSS}\ {\isasymG}\ {\isasymand}\ yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{corollary}\isamarkupfalse%
\ wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}root{\isacharunderscore}{\kern0pt}yield{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}trees{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}trees\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}f\ {\isasymin}\ set\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}t\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}trees\ f{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}rule{\isacharunderscore}{\kern0pt}tree\ {\isasymG}\ t\ {\isasymand}\ root{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymSS}\ {\isasymG}\ {\isasymand}\ yield{\isacharunderscore}{\kern0pt}tree\ t\ {\isacharequal}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{theorem}\isamarkupfalse%
\ soundness{\isacharunderscore}{\kern0pt}build{\isacharunderscore}{\kern0pt}trees{\isacharunderscore}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}wf{\isacharunderscore}{\kern0pt}{\isasymG}\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}is{\isacharunderscore}{\kern0pt}sentence\ {\isasymG}\ {\isasymomega}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}nonempty{\isacharunderscore}{\kern0pt}derives\ {\isasymG}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}build{\isacharunderscore}{\kern0pt}trees\ {\isasymG}\ {\isasymomega}\ {\isacharparenleft}{\kern0pt}{\isasymE}arley{\isacharunderscore}{\kern0pt}list\ {\isasymG}\ {\isasymomega}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ Some\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}f\ {\isasymin}\ set\ fs{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}t\ {\isasymin}\ set\ {\isacharparenleft}{\kern0pt}trees\ f{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymG}\ {\isasymturnstile}\ {\isacharbrackleft}{\kern0pt}{\isasymSS}\ {\isasymG}{\isacharbrackright}{\kern0pt}\ {\isasymRightarrow}\isactrlsup {\isacharasterisk}{\kern0pt}\ {\isasymomega}{\isachardoublequoteclose}%
\isadelimproof
%
\endisadelimproof
%
\isatagproof
%
\endisatagproof
{\isafoldproof}%
%
\isadelimproof
%
\endisadelimproof
%
\begin{isamarkuptext}%
%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsection{A Word on Completeness and Performance \label{sec:word}%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
TODO%
\end{isamarkuptext}\isamarkuptrue%
%
\begin{isamarkuptext}%
How to proof completeness sketch.

Our approach is slow, exponentially slow.
(1) simple improvement for more structural sharing: cons instead of append for complete items reverse
(2) need memoization: even though only one recursive call for different reduction items and same
  predecessor what about different items and same reduction item. But memoization is extremly awkward
  due to the cyclic calls, need to set a dummy.
(3) still not enough sharing see snippet: nodes which have the same tree below them are shared with
  simple improvement and memoization, but packed nodes are not shared.

Overall approach is not very promising, completeness proof very involved, we stop here.%
\end{isamarkuptext}\isamarkuptrue%
%
\begin{isamarkuptext}%
A shared packed parse forest SPPF is a representation designed to reduce the space required to represent multiple derivation
trees for an ambiguous sentence. In an SPPF, nodes which have the same tree below them are shared and nodes which correspond
to different derivations of the same substring from the same non-terminal are combined by creating a packed node for each
family of children. Nodes can be packed only if their yields correspond to the same portion of the input string. Thus, to make it easier
to determine whether two alternates can be packed under a given node, SPPF nodes are labelled with a triple (x,i,j) where
$a_{j+1} \dots a_i$ is a substring matched by x. To obtain a cubic algorithm we use binarised SPPFs which contain intermediate additional
nodes but which are of worst case cubic size. (EXAMPlE SPPF running example???)

We can turn earley's algorithm into a correct parser by adding pointers between items rather than instances of non-terminals, and labelling th epointers
in a way which allows a binariesd SPPF to be constructed by walking the resulting structure. However, inorder to
construct a binarised SPPF we also have to introduce additional nodes for grammar rules of length greater than two,
complicating the final algorithm.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\end{isabellebody}%
\endinput
%:%file=05_Earley_Parser.tex%:%
%:%24=9%:%
%:%36=12%:%
%:%37=13%:%
%:%38=14%:%
%:%39=15%:%
%:%40=16%:%
%:%41=17%:%
%:%42=18%:%
%:%43=19%:%
%:%44=20%:%
%:%45=21%:%
%:%46=22%:%
%:%47=23%:%
%:%48=24%:%
%:%49=25%:%
%:%50=26%:%
%:%51=27%:%
%:%52=28%:%
%:%53=29%:%
%:%54=30%:%
%:%55=31%:%
%:%56=32%:%
%:%57=33%:%
%:%58=34%:%
%:%59=35%:%
%:%60=36%:%
%:%61=37%:%
%:%62=38%:%
%:%63=39%:%
%:%64=40%:%
%:%65=41%:%
%:%66=42%:%
%:%67=43%:%
%:%68=44%:%
%:%69=45%:%
%:%70=46%:%
%:%71=47%:%
%:%72=48%:%
%:%73=49%:%
%:%74=50%:%
%:%75=51%:%
%:%76=52%:%
%:%77=53%:%
%:%78=54%:%
%:%79=55%:%
%:%80=56%:%
%:%81=57%:%
%:%82=58%:%
%:%83=59%:%
%:%84=60%:%
%:%85=61%:%
%:%86=62%:%
%:%87=63%:%
%:%88=64%:%
%:%89=65%:%
%:%90=66%:%
%:%91=67%:%
%:%92=68%:%
%:%93=69%:%
%:%94=70%:%
%:%95=71%:%
%:%96=72%:%
%:%97=73%:%
%:%98=74%:%
%:%99=75%:%
%:%100=76%:%
%:%101=77%:%
%:%102=78%:%
%:%103=79%:%
%:%112=82%:%
%:%124=85%:%
%:%125=86%:%
%:%126=87%:%
%:%127=88%:%
%:%128=89%:%
%:%130=92%:%
%:%131=92%:%
%:%132=93%:%
%:%133=94%:%
%:%134=95%:%
%:%135=96%:%
%:%136=96%:%
%:%137=97%:%
%:%138=98%:%
%:%139=99%:%
%:%140=100%:%
%:%141=100%:%
%:%142=101%:%
%:%143=102%:%
%:%145=105%:%
%:%146=106%:%
%:%147=107%:%
%:%148=108%:%
%:%149=109%:%
%:%150=110%:%
%:%151=111%:%
%:%152=112%:%
%:%153=113%:%
%:%154=114%:%
%:%155=115%:%
%:%156=116%:%
%:%157=117%:%
%:%158=118%:%
%:%159=119%:%
%:%161=122%:%
%:%162=122%:%
%:%163=123%:%
%:%164=124%:%
%:%166=126%:%
%:%167=127%:%
%:%168=128%:%
%:%169=128%:%
%:%170=129%:%
%:%171=130%:%
%:%174=133%:%
%:%175=134%:%
%:%176=135%:%
%:%177=135%:%
%:%178=136%:%
%:%185=139%:%
%:%197=142%:%
%:%198=143%:%
%:%199=144%:%
%:%200=145%:%
%:%201=146%:%
%:%202=147%:%
%:%203=148%:%
%:%204=149%:%
%:%205=150%:%
%:%206=151%:%
%:%207=152%:%
%:%208=153%:%
%:%209=154%:%
%:%210=155%:%
%:%211=156%:%
%:%212=157%:%
%:%213=158%:%
%:%214=159%:%
%:%215=160%:%
%:%216=161%:%
%:%217=162%:%
%:%218=163%:%
%:%219=164%:%
%:%220=165%:%
%:%221=166%:%
%:%223=169%:%
%:%224=169%:%
%:%225=170%:%
%:%226=171%:%
%:%227=172%:%
%:%228=172%:%
%:%229=173%:%
%:%230=174%:%
%:%231=175%:%
%:%232=175%:%
%:%233=176%:%
%:%234=177%:%
%:%235=178%:%
%:%236=178%:%
%:%237=179%:%
%:%239=181%:%
%:%240=182%:%
%:%241=183%:%
%:%242=183%:%
%:%243=184%:%
%:%244=185%:%
%:%245=186%:%
%:%246=187%:%
%:%247=187%:%
%:%248=188%:%
%:%250=190%:%
%:%251=191%:%
%:%252=192%:%
%:%253=192%:%
%:%254=193%:%
%:%257=197%:%
%:%258=198%:%
%:%259=199%:%
%:%260=200%:%
%:%261=201%:%
%:%262=202%:%
%:%263=203%:%
%:%264=204%:%
%:%265=205%:%
%:%266=206%:%
%:%268=209%:%
%:%269=209%:%
%:%270=210%:%
%:%271=211%:%
%:%272=212%:%
%:%273=213%:%
%:%274=214%:%
%:%275=215%:%
%:%276=216%:%
%:%293=223%:%
%:%294=223%:%
%:%295=224%:%
%:%296=225%:%
%:%297=226%:%
%:%298=227%:%
%:%299=228%:%
%:%300=229%:%
%:%317=236%:%
%:%318=236%:%
%:%319=237%:%
%:%320=238%:%
%:%321=239%:%
%:%322=240%:%
%:%323=241%:%
%:%340=248%:%
%:%341=248%:%
%:%342=249%:%
%:%343=250%:%
%:%344=251%:%
%:%345=252%:%
%:%346=253%:%
%:%363=260%:%
%:%364=260%:%
%:%365=261%:%
%:%382=268%:%
%:%383=268%:%
%:%384=269%:%
%:%385=270%:%
%:%386=271%:%
%:%387=272%:%
%:%404=279%:%
%:%405=279%:%
%:%406=280%:%
%:%407=281%:%
%:%408=282%:%
%:%428=288%:%
%:%440=291%:%
%:%441=292%:%
%:%442=293%:%
%:%443=294%:%
%:%444=295%:%
%:%445=296%:%
%:%446=297%:%
%:%447=298%:%
%:%448=299%:%
%:%449=300%:%
%:%450=301%:%
%:%451=302%:%
%:%452=303%:%
%:%453=304%:%
%:%454=305%:%
%:%455=306%:%
%:%456=307%:%
%:%457=308%:%
%:%458=309%:%
%:%459=310%:%
%:%460=311%:%
%:%461=312%:%
%:%462=313%:%
%:%463=314%:%
%:%464=315%:%
%:%465=316%:%
%:%467=319%:%
%:%468=319%:%
%:%469=320%:%
%:%490=342%:%
%:%491=343%:%
%:%492=344%:%
%:%493=345%:%
%:%494=346%:%
%:%495=347%:%
%:%496=348%:%
%:%498=351%:%
%:%499=351%:%
%:%500=352%:%
%:%511=359%:%
%:%523=362%:%
%:%524=363%:%
%:%525=364%:%
%:%526=365%:%
%:%527=366%:%
%:%528=367%:%
%:%529=368%:%
%:%530=369%:%
%:%531=370%:%
%:%532=371%:%
%:%533=372%:%
%:%534=373%:%
%:%535=374%:%
%:%536=375%:%
%:%537=376%:%
%:%538=377%:%
%:%539=378%:%
%:%540=379%:%
%:%541=380%:%
%:%542=381%:%
%:%543=382%:%
%:%544=383%:%
%:%545=384%:%
%:%546=385%:%
%:%547=386%:%
%:%548=387%:%
%:%549=388%:%
%:%550=389%:%
%:%551=390%:%
%:%552=391%:%
%:%553=392%:%
%:%554=393%:%
%:%555=394%:%
%:%556=395%:%
%:%557=396%:%
%:%558=397%:%
%:%559=398%:%
%:%560=399%:%
%:%561=400%:%
%:%562=401%:%
%:%563=402%:%
%:%564=403%:%
%:%565=404%:%
%:%566=405%:%
%:%567=406%:%
%:%568=407%:%
%:%569=408%:%
%:%570=409%:%
%:%572=412%:%
%:%573=412%:%
%:%574=413%:%
%:%577=417%:%
%:%578=418%:%
%:%579=419%:%
%:%580=420%:%
%:%581=421%:%
%:%582=422%:%
%:%583=423%:%
%:%585=426%:%
%:%586=426%:%
%:%587=427%:%
%:%588=428%:%
%:%589=429%:%
%:%590=429%:%
%:%591=430%:%
%:%594=434%:%
%:%595=435%:%
%:%597=438%:%
%:%598=438%:%
%:%599=439%:%
%:%600=440%:%
%:%620=445%:%
%:%632=448%:%
%:%633=449%:%
%:%634=450%:%
%:%635=451%:%
%:%636=452%:%
%:%637=453%:%
%:%639=456%:%
%:%640=456%:%
%:%641=457%:%
%:%642=458%:%
%:%643=459%:%
%:%644=460%:%
%:%659=466%:%
%:%660=467%:%
%:%661=468%:%
%:%662=469%:%
%:%663=470%:%
%:%664=471%:%
%:%665=472%:%
%:%666=473%:%
%:%667=474%:%
%:%668=475%:%
%:%669=476%:%
%:%670=477%:%
%:%671=478%:%
%:%672=479%:%
%:%673=480%:%
%:%674=481%:%
%:%675=482%:%
%:%676=483%:%
%:%677=484%:%
%:%678=485%:%
%:%679=486%:%
%:%680=487%:%
%:%681=488%:%
%:%682=489%:%
%:%683=490%:%
%:%684=491%:%
%:%685=492%:%
%:%686=493%:%
%:%687=494%:%
%:%688=495%:%
%:%689=496%:%
%:%690=497%:%
%:%691=498%:%
%:%692=499%:%
%:%693=500%:%
%:%694=501%:%
%:%695=502%:%
%:%696=503%:%
%:%697=504%:%
%:%698=505%:%
%:%699=506%:%
%:%700=507%:%
%:%701=508%:%
%:%702=509%:%
%:%703=510%:%
%:%704=511%:%
%:%705=512%:%
%:%706=513%:%
%:%707=514%:%
%:%708=515%:%
%:%709=516%:%
%:%710=517%:%
%:%711=518%:%
%:%712=519%:%
%:%713=520%:%
%:%714=521%:%
%:%715=522%:%
%:%716=523%:%
%:%717=524%:%
%:%718=525%:%
%:%719=526%:%
%:%720=527%:%
%:%721=528%:%
%:%722=529%:%
%:%723=530%:%
%:%724=531%:%
%:%725=532%:%
%:%726=533%:%
%:%727=534%:%
%:%728=535%:%
%:%729=536%:%
%:%730=537%:%
%:%731=538%:%
%:%732=539%:%
%:%733=540%:%
%:%734=541%:%
%:%735=542%:%
%:%736=543%:%
%:%737=544%:%
%:%738=545%:%
%:%739=546%:%
%:%740=547%:%
%:%741=548%:%
%:%742=549%:%
%:%743=550%:%
%:%744=551%:%
%:%745=552%:%
%:%746=553%:%
%:%747=554%:%
%:%748=555%:%
%:%749=556%:%
%:%750=557%:%
%:%751=558%:%
%:%752=559%:%
%:%753=560%:%
%:%754=561%:%
%:%755=562%:%
%:%756=563%:%
%:%757=564%:%
%:%761=568%:%
%:%762=569%:%
%:%763=570%:%
%:%764=571%:%
%:%765=572%:%
%:%767=575%:%
%:%768=575%:%
%:%769=576%:%
%:%770=577%:%
%:%771=578%:%
%:%772=579%:%
%:%773=580%:%
%:%774=581%:%
%:%789=587%:%
%:%790=588%:%
%:%791=589%:%
%:%792=590%:%
%:%793=591%:%
%:%794=592%:%
%:%795=593%:%
%:%796=594%:%
%:%797=595%:%
%:%798=596%:%
%:%799=597%:%
%:%800=598%:%
%:%801=599%:%
%:%802=600%:%
%:%803=601%:%
%:%804=602%:%
%:%806=605%:%
%:%807=605%:%
%:%808=606%:%
%:%809=607%:%
%:%810=608%:%
%:%811=609%:%
%:%826=615%:%
%:%827=616%:%
%:%828=617%:%
%:%829=618%:%
%:%831=621%:%
%:%832=621%:%
%:%833=622%:%
%:%834=623%:%
%:%835=624%:%
%:%836=625%:%
%:%851=631%:%
%:%852=632%:%
%:%853=633%:%
%:%854=634%:%
%:%855=635%:%
%:%856=636%:%
%:%857=637%:%
%:%858=638%:%
%:%859=639%:%
%:%868=642%:%
%:%880=645%:%
%:%884=649%:%
%:%885=650%:%
%:%886=651%:%
%:%887=652%:%
%:%888=653%:%
%:%889=654%:%
%:%891=657%:%
%:%892=657%:%
%:%893=658%:%
%:%894=659%:%
%:%895=660%:%
%:%896=661%:%
%:%897=661%:%
%:%898=662%:%
%:%899=663%:%
%:%900=664%:%
%:%901=665%:%
%:%902=665%:%
%:%903=666%:%
%:%904=667%:%
%:%914=673%:%
%:%924=675%:%
%:%925=675%:%
%:%926=676%:%
%:%927=677%:%
%:%930=680%:%
%:%931=681%:%
%:%932=682%:%
%:%933=682%:%
%:%934=683%:%
%:%935=684%:%
%:%947=696%:%
%:%950=697%:%
%:%951=697%:%
%:%952=698%:%
%:%980=726%:%
%:%981=727%:%
%:%982=728%:%
%:%983=728%:%
%:%984=729%:%
%:%994=735%:%
%:%1004=737%:%
%:%1005=737%:%
%:%1006=738%:%
%:%1007=739%:%
%:%1008=740%:%
%:%1009=740%:%
%:%1010=741%:%
%:%1011=742%:%
%:%1012=743%:%
%:%1013=744%:%
%:%1014=744%:%
%:%1015=745%:%
%:%1016=746%:%
%:%1040=753%:%
%:%1050=755%:%
%:%1051=755%:%
%:%1052=756%:%
%:%1053=757%:%
%:%1054=758%:%
%:%1055=759%:%
%:%1056=760%:%
%:%1057=761%:%
%:%1074=768%:%
%:%1075=768%:%
%:%1076=769%:%
%:%1077=770%:%
%:%1078=771%:%
%:%1079=772%:%
%:%1080=773%:%
%:%1081=774%:%
%:%1082=775%:%
%:%1099=782%:%
%:%1100=782%:%
%:%1101=783%:%
%:%1102=784%:%
%:%1103=785%:%
%:%1104=786%:%
%:%1105=787%:%
%:%1106=788%:%
%:%1123=795%:%
%:%1124=795%:%
%:%1125=796%:%
%:%1126=797%:%
%:%1127=798%:%
%:%1128=799%:%
%:%1129=800%:%
%:%1130=801%:%
%:%1131=802%:%
%:%1155=809%:%
%:%1167=812%:%
%:%1171=816%:%
%:%1172=817%:%
%:%1173=818%:%
%:%1174=819%:%
%:%1175=820%:%
%:%1176=821%:%
%:%1177=822%:%
%:%1178=823%:%
%:%1179=824%:%
%:%1180=825%:%
%:%1181=826%:%
%:%1185=830%:%
%:%1186=831%:%
%:%1187=832%:%
%:%1188=833%:%
%:%1189=834%:%
%:%1190=835%:%
%:%1191=836%:%
%:%1192=837%:%
%:%1193=838%:%
%:%1194=839%:%
%:%1195=840%:%
%:%1196=841%:%
