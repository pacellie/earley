%
\begin{isabellebody}%
\setisabellecontext{{\isadigit{0}}{\isadigit{7}}{\isacharunderscore}{\kern0pt}Conclusion}%
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupchapter{Conclusion%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
In this chapter we shortly summarize the contributions of this thesis and point the reader towards
relevant and worthwhile future work.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsection{Summary%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
Chapter 2: introduce Earley recognizer informally with a running example and formulate the final theorem, and three correspoinding lemmas
Chapter 3: formalize Earley recognizer by defining grammar, derivations, Earley items, the basic operations and the generation of a bin
  as the fixpoint, and finally functions Earley and Earley. We then proved well-formedness, soundness and completeness highlighting
  the common proof structure, how to work with and prove things about derivations, and digging into the core argument of the completeness
  proof. Finally we prove that the set of Earley items is finite.
Chapter 4: refine the approach of chapter 3 into a functional executable algorithm modelling the imperative implementation of Earley and
  additionally adding the necessary information to construct parse trees in the form of pointers. We prove termination of the algorithm
  as well as soundness and completeness by proving subsumption in both directions. For the completeness is non-tivial since the algorithm
  is incorrect for grammars containing nonempty derivations. We discuss possible solutions and in the end follow Jones and restrict the
  applicable grammars. We also give an informal arguemnt for the runnign time of the algorithm O(n4) as well as discuss performance improvements as well as
  sketch alternative implementations.
Chapter 5: define and prove the semantics of the pointers of Chapter 4, implement a parse tree algorithm,
  prove termination, soundness and correctness. Then try to generalize this into a parse forest and a corresponding
  algorithm, prove termination and soundness, but also discover some complications (termination and performance),
  ultimately abandon approach and point out a more promising approach.
Chapter 6: highlight the Isabelle version of the running example as well as the main theorems

Overall we formalized Earley original paper (modulo lookahead and some performance improvements) correcting
the pointers to represent pointers such as described in Scott. The main approach of stepwise refinement
of the algorithm and most of the proofs are inspired by the paper of Jones.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsection{Future Work%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
Chapter 3: define the set of Earley items inductively instead of the operational approach which might lead to more elegant proofs
Chapter 4: since algorithm is modelled after imperative Earley, a second refinement step towards an imperative implementation
  also performance improvements: lookhead, set for faster bin append, set for faster predict, set for faster complete
Chapter 5: formalize the SPPF algorithm of Scott in particular the built-in version which would replace
  the classic pointers of earley by a direct construction of a parse forest.%
\end{isamarkuptext}\isamarkuptrue%
%
\begin{isamarkuptext}%
Parse tree disambiguation:

Parser generators like YACC resolve ambiguities in context-free grammers by allowing the user
the specify precedence and associativity declarations restricting the set of allowed parses. But they
do not handle all grammatical restrictions, like 'dangling else' or interactions between binary operators
and functional 'if'-expressions.

Grammar rewriting:

Adams \textit{et al} \cite{Adams:2017} describe a grammar rewriting approach reinterpreting CFGs as
the tree automata, intersectiong them with tree automata encoding desired restrictions and reinterpreting
the results back into CFGs.

Afroozeh \textit{et al} \cite{Afroozeh:2013} present an approach to specifying operator precedence
based on declarative disambiguation rules basing their implementation on grammar rewriting.

Thorup \cite{Thorup:1996} develops two concrete algorithms for disambiguation of grammars based on the idea of 
excluding a certain set of forbidden sub-parse trees.

Parse tree filtering:

Klint \textit{et al} \cite{Klint:1997} propose a framework of filters to describe and compare a wide
range of disambiguation problems in a parser-independent way. A filter is a function that selects
from a set of parse trees the intended trees.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\end{isabellebody}%
\endinput
%:%file=07_Conclusion.tex%:%
%:%24=8%:%
%:%36=11%:%
%:%37=12%:%
%:%46=15%:%
%:%58=18%:%
%:%59=19%:%
%:%60=20%:%
%:%61=21%:%
%:%62=22%:%
%:%63=23%:%
%:%64=24%:%
%:%65=25%:%
%:%66=26%:%
%:%67=27%:%
%:%68=28%:%
%:%69=29%:%
%:%70=30%:%
%:%71=31%:%
%:%72=32%:%
%:%73=33%:%
%:%74=34%:%
%:%75=35%:%
%:%76=36%:%
%:%77=37%:%
%:%86=40%:%
%:%98=43%:%
%:%99=44%:%
%:%100=45%:%
%:%101=46%:%
%:%102=47%:%
%:%106=51%:%
%:%107=52%:%
%:%108=53%:%
%:%109=54%:%
%:%110=55%:%
%:%111=56%:%
%:%112=57%:%
%:%113=58%:%
%:%114=59%:%
%:%115=60%:%
%:%116=61%:%
%:%117=62%:%
%:%118=63%:%
%:%119=64%:%
%:%120=65%:%
%:%121=66%:%
%:%122=67%:%
%:%123=68%:%
%:%124=69%:%
%:%125=70%:%
%:%126=71%:%
%:%127=72%:%
%:%128=73%:%
%:%129=74%:%
